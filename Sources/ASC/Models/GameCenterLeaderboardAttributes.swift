//
// GameCenterLeaderboardAttributes.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct GameCenterLeaderboardAttributes: Sendable, Codable, JSONEncodable, Hashable {

    public enum SubmissionType: String, Sendable, Codable, CaseIterable, CaseIterableDefaultsLast {
        case bestScore = "BEST_SCORE"
        case mostRecentScore = "MOST_RECENT_SCORE"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum ScoreSortType: String, Sendable, Codable, CaseIterable, CaseIterableDefaultsLast {
        case asc = "ASC"
        case desc = "DESC"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public var defaultFormatter: GameCenterLeaderboardFormatter?
    public var referenceName: String?
    public var vendorIdentifier: String?
    public var submissionType: SubmissionType?
    public var scoreSortType: ScoreSortType?
    public var scoreRangeStart: Decimal?
    public var scoreRangeEnd: Decimal?
    public var recurrenceStartDate: Date?
    public var recurrenceDuration: String?
    public var recurrenceRule: String?
    public var archived: Bool?

    public init(defaultFormatter: GameCenterLeaderboardFormatter? = nil, referenceName: String? = nil, vendorIdentifier: String? = nil, submissionType: SubmissionType? = nil, scoreSortType: ScoreSortType? = nil, scoreRangeStart: Decimal? = nil, scoreRangeEnd: Decimal? = nil, recurrenceStartDate: Date? = nil, recurrenceDuration: String? = nil, recurrenceRule: String? = nil, archived: Bool? = nil) {
        self.defaultFormatter = defaultFormatter
        self.referenceName = referenceName
        self.vendorIdentifier = vendorIdentifier
        self.submissionType = submissionType
        self.scoreSortType = scoreSortType
        self.scoreRangeStart = scoreRangeStart
        self.scoreRangeEnd = scoreRangeEnd
        self.recurrenceStartDate = recurrenceStartDate
        self.recurrenceDuration = recurrenceDuration
        self.recurrenceRule = recurrenceRule
        self.archived = archived
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case defaultFormatter
        case referenceName
        case vendorIdentifier
        case submissionType
        case scoreSortType
        case scoreRangeStart
        case scoreRangeEnd
        case recurrenceStartDate
        case recurrenceDuration
        case recurrenceRule
        case archived
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(defaultFormatter, forKey: .defaultFormatter)
        try container.encodeIfPresent(referenceName, forKey: .referenceName)
        try container.encodeIfPresent(vendorIdentifier, forKey: .vendorIdentifier)
        try container.encodeIfPresent(submissionType, forKey: .submissionType)
        try container.encodeIfPresent(scoreSortType, forKey: .scoreSortType)
        try container.encodeIfPresent(scoreRangeStart, forKey: .scoreRangeStart)
        try container.encodeIfPresent(scoreRangeEnd, forKey: .scoreRangeEnd)
        try container.encodeIfPresent(recurrenceStartDate, forKey: .recurrenceStartDate)
        try container.encodeIfPresent(recurrenceDuration, forKey: .recurrenceDuration)
        try container.encodeIfPresent(recurrenceRule, forKey: .recurrenceRule)
        try container.encodeIfPresent(archived, forKey: .archived)
    }
}

