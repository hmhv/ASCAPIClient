//
// WinBackOfferAttributes.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

public struct WinBackOfferAttributes: Sendable, Codable, JSONEncodable, Hashable {

    public enum Priority: String, Sendable, Codable, CaseIterable, CaseIterableDefaultsLast {
        case high = "HIGH"
        case normal = "NORMAL"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public enum PromotionIntent: String, Sendable, Codable, CaseIterable, CaseIterableDefaultsLast {
        case notPromoted = "NOT_PROMOTED"
        case useAutoGeneratedAssets = "USE_AUTO_GENERATED_ASSETS"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public var referenceName: String?
    public var offerId: String?
    public var duration: SubscriptionOfferDuration?
    public var offerMode: SubscriptionOfferMode?
    public var periodCount: Int?
    public var customerEligibilityPaidSubscriptionDurationInMonths: Int?
    public var customerEligibilityTimeSinceLastSubscribedInMonths: IntegerRange?
    public var customerEligibilityWaitBetweenOffersInMonths: Int?
    public var startDate: Date?
    public var endDate: Date?
    public var priority: Priority?
    public var promotionIntent: PromotionIntent?

    public init(referenceName: String? = nil, offerId: String? = nil, duration: SubscriptionOfferDuration? = nil, offerMode: SubscriptionOfferMode? = nil, periodCount: Int? = nil, customerEligibilityPaidSubscriptionDurationInMonths: Int? = nil, customerEligibilityTimeSinceLastSubscribedInMonths: IntegerRange? = nil, customerEligibilityWaitBetweenOffersInMonths: Int? = nil, startDate: Date? = nil, endDate: Date? = nil, priority: Priority? = nil, promotionIntent: PromotionIntent? = nil) {
        self.referenceName = referenceName
        self.offerId = offerId
        self.duration = duration
        self.offerMode = offerMode
        self.periodCount = periodCount
        self.customerEligibilityPaidSubscriptionDurationInMonths = customerEligibilityPaidSubscriptionDurationInMonths
        self.customerEligibilityTimeSinceLastSubscribedInMonths = customerEligibilityTimeSinceLastSubscribedInMonths
        self.customerEligibilityWaitBetweenOffersInMonths = customerEligibilityWaitBetweenOffersInMonths
        self.startDate = startDate
        self.endDate = endDate
        self.priority = priority
        self.promotionIntent = promotionIntent
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case referenceName
        case offerId
        case duration
        case offerMode
        case periodCount
        case customerEligibilityPaidSubscriptionDurationInMonths
        case customerEligibilityTimeSinceLastSubscribedInMonths
        case customerEligibilityWaitBetweenOffersInMonths
        case startDate
        case endDate
        case priority
        case promotionIntent
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(referenceName, forKey: .referenceName)
        try container.encodeIfPresent(offerId, forKey: .offerId)
        try container.encodeIfPresent(duration, forKey: .duration)
        try container.encodeIfPresent(offerMode, forKey: .offerMode)
        try container.encodeIfPresent(periodCount, forKey: .periodCount)
        try container.encodeIfPresent(customerEligibilityPaidSubscriptionDurationInMonths, forKey: .customerEligibilityPaidSubscriptionDurationInMonths)
        try container.encodeIfPresent(customerEligibilityTimeSinceLastSubscribedInMonths, forKey: .customerEligibilityTimeSinceLastSubscribedInMonths)
        try container.encodeIfPresent(customerEligibilityWaitBetweenOffersInMonths, forKey: .customerEligibilityWaitBetweenOffersInMonths)
        try container.encodeIfPresent(startDate, forKey: .startDate)
        try container.encodeIfPresent(endDate, forKey: .endDate)
        try container.encodeIfPresent(priority, forKey: .priority)
        try container.encodeIfPresent(promotionIntent, forKey: .promotionIntent)
    }
}

