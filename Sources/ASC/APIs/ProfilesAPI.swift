//
// ProfilesAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

open class ProfilesAPI {

    /**
     * enum for parameter fieldsBundleIds
     */
    public enum FieldsBundleIds_profilesBundleIdGetToOneRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case bundleidcapabilities = "bundleIdCapabilities"
        case identifier = "identifier"
        case name = "name"
        case platform = "platform"
        case profiles = "profiles"
        case seedid = "seedId"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsBundleIds: (query) the fields to include for returned resources of type bundleIds (optional)
     - returns: BundleIdResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func profilesBundleIdGetToOneRelated(id: String, fieldsBundleIds: [FieldsBundleIds_profilesBundleIdGetToOneRelated]? = nil) async throws -> BundleIdResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = profilesBundleIdGetToOneRelatedWithRequestBuilder(id: id, fieldsBundleIds: fieldsBundleIds).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: BundleIdResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func profilesBundleIdGetToOneRelated(urlString: String) async throws -> BundleIdResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = profilesBundleIdGetToOneRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/profiles/{id}/bundleId
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsBundleIds: (query) the fields to include for returned resources of type bundleIds (optional)
     - returns: RequestBuilder<BundleIdResponse> 
     */
    open class func profilesBundleIdGetToOneRelatedWithRequestBuilder(id: String, fieldsBundleIds: [FieldsBundleIds_profilesBundleIdGetToOneRelated]? = nil) -> RequestBuilder<BundleIdResponse> {
        var localVariablePath = "/v1/profiles/{id}/bundleId"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[bundleIds]": fieldsBundleIds?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<BundleIdResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/profiles/{id}/bundleId
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<BundleIdResponse> 
     */
    open class func profilesBundleIdGetToOneRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<BundleIdResponse> {
        let localVariableRequestBuilder: RequestBuilder<BundleIdResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsCertificates
     */
    public enum FieldsCertificates_profilesCertificatesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case certificatecontent = "certificateContent"
        case certificatetype = "certificateType"
        case csrcontent = "csrContent"
        case displayname = "displayName"
        case expirationdate = "expirationDate"
        case name = "name"
        case platform = "platform"
        case serialnumber = "serialNumber"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsCertificates: (query) the fields to include for returned resources of type certificates (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - returns: CertificatesResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func profilesCertificatesGetToManyRelated(id: String, fieldsCertificates: [FieldsCertificates_profilesCertificatesGetToManyRelated]? = nil, limit: Int? = nil) async throws -> CertificatesResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = profilesCertificatesGetToManyRelatedWithRequestBuilder(id: id, fieldsCertificates: fieldsCertificates, limit: limit).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: CertificatesResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func profilesCertificatesGetToManyRelated(urlString: String) async throws -> CertificatesResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = profilesCertificatesGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/profiles/{id}/certificates
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsCertificates: (query) the fields to include for returned resources of type certificates (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - returns: RequestBuilder<CertificatesResponse> 
     */
    open class func profilesCertificatesGetToManyRelatedWithRequestBuilder(id: String, fieldsCertificates: [FieldsCertificates_profilesCertificatesGetToManyRelated]? = nil, limit: Int? = nil) -> RequestBuilder<CertificatesResponse> {
        var localVariablePath = "/v1/profiles/{id}/certificates"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[certificates]": fieldsCertificates?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<CertificatesResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/profiles/{id}/certificates
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<CertificatesResponse> 
     */
    open class func profilesCertificatesGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<CertificatesResponse> {
        let localVariableRequestBuilder: RequestBuilder<CertificatesResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**

     - parameter profileCreateRequest: (body) Profile representation 
     - returns: ProfileResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func profilesCreateInstance(profileCreateRequest: ProfileCreateRequest) async throws -> ProfileResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = profilesCreateInstanceWithRequestBuilder(profileCreateRequest: profileCreateRequest).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: ProfileResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func profilesCreateInstance(urlString: String) async throws -> ProfileResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = profilesCreateInstanceWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - POST /v1/profiles
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter profileCreateRequest: (body) Profile representation 
     - returns: RequestBuilder<ProfileResponse> 
     */
    open class func profilesCreateInstanceWithRequestBuilder(profileCreateRequest: ProfileCreateRequest) -> RequestBuilder<ProfileResponse> {
        let localVariablePath = "/v1/profiles"
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: profileCreateRequest)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ProfileResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - POST /v1/profiles
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<ProfileResponse> 
     */
    open class func profilesCreateInstanceWithRequestBuilder(urlString: String) -> RequestBuilder<ProfileResponse> {
        let localVariableRequestBuilder: RequestBuilder<ProfileResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "POST", URLString: urlString, parameters: nil)
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - returns: Void
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func profilesDeleteInstance(id: String) async throws {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = profilesDeleteInstanceWithRequestBuilder(id: id).execute { result in
                    switch result {
                    case .success:
                        continuation.resume(returning: ())
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: Void
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func profilesDeleteInstance(urlString: String) async throws {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = profilesDeleteInstanceWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case .success:
                        continuation.resume(returning: ())
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - DELETE /v1/profiles/{id}
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - returns: RequestBuilder<Void> 
     */
    open class func profilesDeleteInstanceWithRequestBuilder(id: String) -> RequestBuilder<Void> {
        var localVariablePath = "/v1/profiles/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = ASCAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - DELETE /v1/profiles/{id}
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<Void> 
     */
    open class func profilesDeleteInstanceWithRequestBuilder(urlString: String) -> RequestBuilder<Void> {
        let localVariableRequestBuilder: RequestBuilder<Void>.Type = ASCAPI.requestBuilderFactory.getNonDecodableBuilder()
        return localVariableRequestBuilder.init(method: "DELETE", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsDevices
     */
    public enum FieldsDevices_profilesDevicesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case addeddate = "addedDate"
        case deviceclass = "deviceClass"
        case model = "model"
        case name = "name"
        case platform = "platform"
        case status = "status"
        case udid = "udid"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsDevices: (query) the fields to include for returned resources of type devices (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - returns: DevicesResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func profilesDevicesGetToManyRelated(id: String, fieldsDevices: [FieldsDevices_profilesDevicesGetToManyRelated]? = nil, limit: Int? = nil) async throws -> DevicesResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = profilesDevicesGetToManyRelatedWithRequestBuilder(id: id, fieldsDevices: fieldsDevices, limit: limit).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: DevicesResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func profilesDevicesGetToManyRelated(urlString: String) async throws -> DevicesResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = profilesDevicesGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/profiles/{id}/devices
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsDevices: (query) the fields to include for returned resources of type devices (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - returns: RequestBuilder<DevicesResponse> 
     */
    open class func profilesDevicesGetToManyRelatedWithRequestBuilder(id: String, fieldsDevices: [FieldsDevices_profilesDevicesGetToManyRelated]? = nil, limit: Int? = nil) -> RequestBuilder<DevicesResponse> {
        var localVariablePath = "/v1/profiles/{id}/devices"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[devices]": fieldsDevices?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<DevicesResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/profiles/{id}/devices
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<DevicesResponse> 
     */
    open class func profilesDevicesGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<DevicesResponse> {
        let localVariableRequestBuilder: RequestBuilder<DevicesResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter filterProfileState
     */
    public enum FilterProfileState_profilesGetCollection: String, CaseIterable, JSONEncodable {
        case active = "ACTIVE"
        case invalid = "INVALID"
    }

    /**
     * enum for parameter filterProfileType
     */
    public enum FilterProfileType_profilesGetCollection: String, CaseIterable, JSONEncodable {
        case iosAppDevelopment = "IOS_APP_DEVELOPMENT"
        case iosAppStore = "IOS_APP_STORE"
        case iosAppAdhoc = "IOS_APP_ADHOC"
        case iosAppInhouse = "IOS_APP_INHOUSE"
        case macAppDevelopment = "MAC_APP_DEVELOPMENT"
        case macAppStore = "MAC_APP_STORE"
        case macAppDirect = "MAC_APP_DIRECT"
        case tvosAppDevelopment = "TVOS_APP_DEVELOPMENT"
        case tvosAppStore = "TVOS_APP_STORE"
        case tvosAppAdhoc = "TVOS_APP_ADHOC"
        case tvosAppInhouse = "TVOS_APP_INHOUSE"
        case macCatalystAppDevelopment = "MAC_CATALYST_APP_DEVELOPMENT"
        case macCatalystAppStore = "MAC_CATALYST_APP_STORE"
        case macCatalystAppDirect = "MAC_CATALYST_APP_DIRECT"
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_profilesGetCollection: String, CaseIterable, JSONEncodable {
        case id = "id"
        case id_desc = "-id"
        case name = "name"
        case name_desc = "-name"
        case profilestate = "profileState"
        case profilestate_desc = "-profileState"
        case profiletype = "profileType"
        case profiletype_desc = "-profileType"
    }

    /**
     * enum for parameter fieldsProfiles
     */
    public enum FieldsProfiles_profilesGetCollection: String, CaseIterable, JSONEncodable {
        case bundleid = "bundleId"
        case certificates = "certificates"
        case createddate = "createdDate"
        case devices = "devices"
        case expirationdate = "expirationDate"
        case name = "name"
        case platform = "platform"
        case profilecontent = "profileContent"
        case profilestate = "profileState"
        case profiletype = "profileType"
        case uuid = "uuid"
    }

    /**
     * enum for parameter include
     */
    public enum Include_profilesGetCollection: String, CaseIterable, JSONEncodable {
        case bundleid = "bundleId"
        case certificates = "certificates"
        case devices = "devices"
    }

    /**
     * enum for parameter fieldsCertificates
     */
    public enum FieldsCertificates_profilesGetCollection: String, CaseIterable, JSONEncodable {
        case certificatecontent = "certificateContent"
        case certificatetype = "certificateType"
        case csrcontent = "csrContent"
        case displayname = "displayName"
        case expirationdate = "expirationDate"
        case name = "name"
        case platform = "platform"
        case serialnumber = "serialNumber"
    }

    /**
     * enum for parameter fieldsDevices
     */
    public enum FieldsDevices_profilesGetCollection: String, CaseIterable, JSONEncodable {
        case addeddate = "addedDate"
        case deviceclass = "deviceClass"
        case model = "model"
        case name = "name"
        case platform = "platform"
        case status = "status"
        case udid = "udid"
    }

    /**
     * enum for parameter fieldsBundleIds
     */
    public enum FieldsBundleIds_profilesGetCollection: String, CaseIterable, JSONEncodable {
        case app = "app"
        case bundleidcapabilities = "bundleIdCapabilities"
        case identifier = "identifier"
        case name = "name"
        case platform = "platform"
        case profiles = "profiles"
        case seedid = "seedId"
    }

    /**

     - parameter filterName: (query) filter by attribute &#39;name&#39; (optional)
     - parameter filterProfileState: (query) filter by attribute &#39;profileState&#39; (optional)
     - parameter filterProfileType: (query) filter by attribute &#39;profileType&#39; (optional)
     - parameter filterId: (query) filter by id(s) (optional)
     - parameter sort: (query) comma-separated list of sort expressions; resources will be sorted as specified (optional)
     - parameter fieldsProfiles: (query) the fields to include for returned resources of type profiles (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - parameter fieldsCertificates: (query) the fields to include for returned resources of type certificates (optional)
     - parameter fieldsDevices: (query) the fields to include for returned resources of type devices (optional)
     - parameter fieldsBundleIds: (query) the fields to include for returned resources of type bundleIds (optional)
     - parameter limitCertificates: (query) maximum number of related certificates returned (when they are included) (optional)
     - parameter limitDevices: (query) maximum number of related devices returned (when they are included) (optional)
     - returns: ProfilesResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func profilesGetCollection(filterName: [String]? = nil, filterProfileState: [FilterProfileState_profilesGetCollection]? = nil, filterProfileType: [FilterProfileType_profilesGetCollection]? = nil, filterId: [String]? = nil, sort: [Sort_profilesGetCollection]? = nil, fieldsProfiles: [FieldsProfiles_profilesGetCollection]? = nil, limit: Int? = nil, include: [Include_profilesGetCollection]? = nil, fieldsCertificates: [FieldsCertificates_profilesGetCollection]? = nil, fieldsDevices: [FieldsDevices_profilesGetCollection]? = nil, fieldsBundleIds: [FieldsBundleIds_profilesGetCollection]? = nil, limitCertificates: Int? = nil, limitDevices: Int? = nil) async throws -> ProfilesResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = profilesGetCollectionWithRequestBuilder(filterName: filterName, filterProfileState: filterProfileState, filterProfileType: filterProfileType, filterId: filterId, sort: sort, fieldsProfiles: fieldsProfiles, limit: limit, include: include, fieldsCertificates: fieldsCertificates, fieldsDevices: fieldsDevices, fieldsBundleIds: fieldsBundleIds, limitCertificates: limitCertificates, limitDevices: limitDevices).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: ProfilesResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func profilesGetCollection(urlString: String) async throws -> ProfilesResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = profilesGetCollectionWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/profiles
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter filterName: (query) filter by attribute &#39;name&#39; (optional)
     - parameter filterProfileState: (query) filter by attribute &#39;profileState&#39; (optional)
     - parameter filterProfileType: (query) filter by attribute &#39;profileType&#39; (optional)
     - parameter filterId: (query) filter by id(s) (optional)
     - parameter sort: (query) comma-separated list of sort expressions; resources will be sorted as specified (optional)
     - parameter fieldsProfiles: (query) the fields to include for returned resources of type profiles (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - parameter fieldsCertificates: (query) the fields to include for returned resources of type certificates (optional)
     - parameter fieldsDevices: (query) the fields to include for returned resources of type devices (optional)
     - parameter fieldsBundleIds: (query) the fields to include for returned resources of type bundleIds (optional)
     - parameter limitCertificates: (query) maximum number of related certificates returned (when they are included) (optional)
     - parameter limitDevices: (query) maximum number of related devices returned (when they are included) (optional)
     - returns: RequestBuilder<ProfilesResponse> 
     */
    open class func profilesGetCollectionWithRequestBuilder(filterName: [String]? = nil, filterProfileState: [FilterProfileState_profilesGetCollection]? = nil, filterProfileType: [FilterProfileType_profilesGetCollection]? = nil, filterId: [String]? = nil, sort: [Sort_profilesGetCollection]? = nil, fieldsProfiles: [FieldsProfiles_profilesGetCollection]? = nil, limit: Int? = nil, include: [Include_profilesGetCollection]? = nil, fieldsCertificates: [FieldsCertificates_profilesGetCollection]? = nil, fieldsDevices: [FieldsDevices_profilesGetCollection]? = nil, fieldsBundleIds: [FieldsBundleIds_profilesGetCollection]? = nil, limitCertificates: Int? = nil, limitDevices: Int? = nil) -> RequestBuilder<ProfilesResponse> {
        let localVariablePath = "/v1/profiles"
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "filter[name]": filterName?.encodeToJSON(),
            "filter[profileState]": filterProfileState?.encodeToJSON(),
            "filter[profileType]": filterProfileType?.encodeToJSON(),
            "filter[id]": filterId?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "fields[profiles]": fieldsProfiles?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "include": include?.encodeToJSON(),
            "fields[certificates]": fieldsCertificates?.encodeToJSON(),
            "fields[devices]": fieldsDevices?.encodeToJSON(),
            "fields[bundleIds]": fieldsBundleIds?.encodeToJSON(),
            "limit[certificates]": limitCertificates?.encodeToJSON(),
            "limit[devices]": limitDevices?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ProfilesResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/profiles
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<ProfilesResponse> 
     */
    open class func profilesGetCollectionWithRequestBuilder(urlString: String) -> RequestBuilder<ProfilesResponse> {
        let localVariableRequestBuilder: RequestBuilder<ProfilesResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsProfiles
     */
    public enum FieldsProfiles_profilesGetInstance: String, CaseIterable, JSONEncodable {
        case bundleid = "bundleId"
        case certificates = "certificates"
        case createddate = "createdDate"
        case devices = "devices"
        case expirationdate = "expirationDate"
        case name = "name"
        case platform = "platform"
        case profilecontent = "profileContent"
        case profilestate = "profileState"
        case profiletype = "profileType"
        case uuid = "uuid"
    }

    /**
     * enum for parameter include
     */
    public enum Include_profilesGetInstance: String, CaseIterable, JSONEncodable {
        case bundleid = "bundleId"
        case certificates = "certificates"
        case devices = "devices"
    }

    /**
     * enum for parameter fieldsCertificates
     */
    public enum FieldsCertificates_profilesGetInstance: String, CaseIterable, JSONEncodable {
        case certificatecontent = "certificateContent"
        case certificatetype = "certificateType"
        case csrcontent = "csrContent"
        case displayname = "displayName"
        case expirationdate = "expirationDate"
        case name = "name"
        case platform = "platform"
        case serialnumber = "serialNumber"
    }

    /**
     * enum for parameter fieldsDevices
     */
    public enum FieldsDevices_profilesGetInstance: String, CaseIterable, JSONEncodable {
        case addeddate = "addedDate"
        case deviceclass = "deviceClass"
        case model = "model"
        case name = "name"
        case platform = "platform"
        case status = "status"
        case udid = "udid"
    }

    /**
     * enum for parameter fieldsBundleIds
     */
    public enum FieldsBundleIds_profilesGetInstance: String, CaseIterable, JSONEncodable {
        case app = "app"
        case bundleidcapabilities = "bundleIdCapabilities"
        case identifier = "identifier"
        case name = "name"
        case platform = "platform"
        case profiles = "profiles"
        case seedid = "seedId"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsProfiles: (query) the fields to include for returned resources of type profiles (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - parameter fieldsCertificates: (query) the fields to include for returned resources of type certificates (optional)
     - parameter fieldsDevices: (query) the fields to include for returned resources of type devices (optional)
     - parameter fieldsBundleIds: (query) the fields to include for returned resources of type bundleIds (optional)
     - parameter limitCertificates: (query) maximum number of related certificates returned (when they are included) (optional)
     - parameter limitDevices: (query) maximum number of related devices returned (when they are included) (optional)
     - returns: ProfileResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func profilesGetInstance(id: String, fieldsProfiles: [FieldsProfiles_profilesGetInstance]? = nil, include: [Include_profilesGetInstance]? = nil, fieldsCertificates: [FieldsCertificates_profilesGetInstance]? = nil, fieldsDevices: [FieldsDevices_profilesGetInstance]? = nil, fieldsBundleIds: [FieldsBundleIds_profilesGetInstance]? = nil, limitCertificates: Int? = nil, limitDevices: Int? = nil) async throws -> ProfileResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = profilesGetInstanceWithRequestBuilder(id: id, fieldsProfiles: fieldsProfiles, include: include, fieldsCertificates: fieldsCertificates, fieldsDevices: fieldsDevices, fieldsBundleIds: fieldsBundleIds, limitCertificates: limitCertificates, limitDevices: limitDevices).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: ProfileResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func profilesGetInstance(urlString: String) async throws -> ProfileResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = profilesGetInstanceWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/profiles/{id}
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsProfiles: (query) the fields to include for returned resources of type profiles (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - parameter fieldsCertificates: (query) the fields to include for returned resources of type certificates (optional)
     - parameter fieldsDevices: (query) the fields to include for returned resources of type devices (optional)
     - parameter fieldsBundleIds: (query) the fields to include for returned resources of type bundleIds (optional)
     - parameter limitCertificates: (query) maximum number of related certificates returned (when they are included) (optional)
     - parameter limitDevices: (query) maximum number of related devices returned (when they are included) (optional)
     - returns: RequestBuilder<ProfileResponse> 
     */
    open class func profilesGetInstanceWithRequestBuilder(id: String, fieldsProfiles: [FieldsProfiles_profilesGetInstance]? = nil, include: [Include_profilesGetInstance]? = nil, fieldsCertificates: [FieldsCertificates_profilesGetInstance]? = nil, fieldsDevices: [FieldsDevices_profilesGetInstance]? = nil, fieldsBundleIds: [FieldsBundleIds_profilesGetInstance]? = nil, limitCertificates: Int? = nil, limitDevices: Int? = nil) -> RequestBuilder<ProfileResponse> {
        var localVariablePath = "/v1/profiles/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[profiles]": fieldsProfiles?.encodeToJSON(),
            "include": include?.encodeToJSON(),
            "fields[certificates]": fieldsCertificates?.encodeToJSON(),
            "fields[devices]": fieldsDevices?.encodeToJSON(),
            "fields[bundleIds]": fieldsBundleIds?.encodeToJSON(),
            "limit[certificates]": limitCertificates?.encodeToJSON(),
            "limit[devices]": limitDevices?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ProfileResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/profiles/{id}
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<ProfileResponse> 
     */
    open class func profilesGetInstanceWithRequestBuilder(urlString: String) -> RequestBuilder<ProfileResponse> {
        let localVariableRequestBuilder: RequestBuilder<ProfileResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }
}
