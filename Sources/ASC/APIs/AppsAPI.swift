//
// AppsAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

open class AppsAPI {

    /**
     * enum for parameter fieldsAppClips
     */
    public enum FieldsAppClips_appsAppClipsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appclipadvancedexperiences = "appClipAdvancedExperiences"
        case appclipdefaultexperiences = "appClipDefaultExperiences"
        case bundleid = "bundleId"
    }

    /**
     * enum for parameter fieldsApps
     */
    public enum FieldsApps_appsAppClipsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appclips = "appClips"
        case appcustomproductpages = "appCustomProductPages"
        case appevents = "appEvents"
        case appinfos = "appInfos"
        case appstoreversions = "appStoreVersions"
        case availableinnewterritories = "availableInNewTerritories"
        case availableterritories = "availableTerritories"
        case betaapplocalizations = "betaAppLocalizations"
        case betaappreviewdetail = "betaAppReviewDetail"
        case betagroups = "betaGroups"
        case betalicenseagreement = "betaLicenseAgreement"
        case betatesters = "betaTesters"
        case builds = "builds"
        case bundleid = "bundleId"
        case ciproduct = "ciProduct"
        case contentrightsdeclaration = "contentRightsDeclaration"
        case enduserlicenseagreement = "endUserLicenseAgreement"
        case gamecenterenabledversions = "gameCenterEnabledVersions"
        case inapppurchases = "inAppPurchases"
        case isoreverwasmadeforkids = "isOrEverWasMadeForKids"
        case name = "name"
        case perfpowermetrics = "perfPowerMetrics"
        case preorder = "preOrder"
        case prereleaseversions = "preReleaseVersions"
        case pricepoints = "pricePoints"
        case prices = "prices"
        case primarylocale = "primaryLocale"
        case reviewsubmissions = "reviewSubmissions"
        case sku = "sku"
        case subscriptionstatusurl = "subscriptionStatusUrl"
        case subscriptionstatusurlforsandbox = "subscriptionStatusUrlForSandbox"
        case subscriptionstatusurlversion = "subscriptionStatusUrlVersion"
        case subscriptionstatusurlversionforsandbox = "subscriptionStatusUrlVersionForSandbox"
    }

    /**
     * enum for parameter fieldsAppClipDefaultExperiences
     */
    public enum FieldsAppClipDefaultExperiences_appsAppClipsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case action = "action"
        case appclip = "appClip"
        case appclipappstorereviewdetail = "appClipAppStoreReviewDetail"
        case appclipdefaultexperiencelocalizations = "appClipDefaultExperienceLocalizations"
        case appclipdefaultexperiencetemplate = "appClipDefaultExperienceTemplate"
        case releasewithappstoreversion = "releaseWithAppStoreVersion"
    }

    /**
     * enum for parameter include
     */
    public enum Include_appsAppClipsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appclipdefaultexperiences = "appClipDefaultExperiences"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter filterBundleId: (query) filter by attribute &#39;bundleId&#39; (optional)
     - parameter fieldsAppClips: (query) the fields to include for returned resources of type appClips (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter fieldsAppClipDefaultExperiences: (query) the fields to include for returned resources of type appClipDefaultExperiences (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitAppClipDefaultExperiences: (query) maximum number of related appClipDefaultExperiences returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: AppClipsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsAppClipsGetToManyRelated(id: String, filterBundleId: [String]? = nil, fieldsAppClips: [FieldsAppClips_appsAppClipsGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsAppClipsGetToManyRelated]? = nil, fieldsAppClipDefaultExperiences: [FieldsAppClipDefaultExperiences_appsAppClipsGetToManyRelated]? = nil, limit: Int? = nil, limitAppClipDefaultExperiences: Int? = nil, include: [Include_appsAppClipsGetToManyRelated]? = nil) async throws -> AppClipsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsAppClipsGetToManyRelatedWithRequestBuilder(id: id, filterBundleId: filterBundleId, fieldsAppClips: fieldsAppClips, fieldsApps: fieldsApps, fieldsAppClipDefaultExperiences: fieldsAppClipDefaultExperiences, limit: limit, limitAppClipDefaultExperiences: limitAppClipDefaultExperiences, include: include).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: AppClipsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsAppClipsGetToManyRelated(urlString: String) async throws -> AppClipsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsAppClipsGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/appClips
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter filterBundleId: (query) filter by attribute &#39;bundleId&#39; (optional)
     - parameter fieldsAppClips: (query) the fields to include for returned resources of type appClips (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter fieldsAppClipDefaultExperiences: (query) the fields to include for returned resources of type appClipDefaultExperiences (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitAppClipDefaultExperiences: (query) maximum number of related appClipDefaultExperiences returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: RequestBuilder<AppClipsResponse> 
     */
    open class func appsAppClipsGetToManyRelatedWithRequestBuilder(id: String, filterBundleId: [String]? = nil, fieldsAppClips: [FieldsAppClips_appsAppClipsGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsAppClipsGetToManyRelated]? = nil, fieldsAppClipDefaultExperiences: [FieldsAppClipDefaultExperiences_appsAppClipsGetToManyRelated]? = nil, limit: Int? = nil, limitAppClipDefaultExperiences: Int? = nil, include: [Include_appsAppClipsGetToManyRelated]? = nil) -> RequestBuilder<AppClipsResponse> {
        var localVariablePath = "/v1/apps/{id}/appClips"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "filter[bundleId]": filterBundleId?.encodeToJSON(),
            "fields[appClips]": fieldsAppClips?.encodeToJSON(),
            "fields[apps]": fieldsApps?.encodeToJSON(),
            "fields[appClipDefaultExperiences]": fieldsAppClipDefaultExperiences?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "limit[appClipDefaultExperiences]": limitAppClipDefaultExperiences?.encodeToJSON(),
            "include": include?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AppClipsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/appClips
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<AppClipsResponse> 
     */
    open class func appsAppClipsGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<AppClipsResponse> {
        let localVariableRequestBuilder: RequestBuilder<AppClipsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsAppCustomProductPages
     */
    public enum FieldsAppCustomProductPages_appsAppCustomProductPagesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appcustomproductpageversions = "appCustomProductPageVersions"
        case appstoreversiontemplate = "appStoreVersionTemplate"
        case customproductpagetemplate = "customProductPageTemplate"
        case name = "name"
        case url = "url"
        case visible = "visible"
    }

    /**
     * enum for parameter fieldsAppCustomProductPageVersions
     */
    public enum FieldsAppCustomProductPageVersions_appsAppCustomProductPagesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appcustomproductpage = "appCustomProductPage"
        case appcustomproductpagelocalizations = "appCustomProductPageLocalizations"
        case state = "state"
        case version = "version"
    }

    /**
     * enum for parameter fieldsApps
     */
    public enum FieldsApps_appsAppCustomProductPagesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appclips = "appClips"
        case appcustomproductpages = "appCustomProductPages"
        case appevents = "appEvents"
        case appinfos = "appInfos"
        case appstoreversions = "appStoreVersions"
        case availableinnewterritories = "availableInNewTerritories"
        case availableterritories = "availableTerritories"
        case betaapplocalizations = "betaAppLocalizations"
        case betaappreviewdetail = "betaAppReviewDetail"
        case betagroups = "betaGroups"
        case betalicenseagreement = "betaLicenseAgreement"
        case betatesters = "betaTesters"
        case builds = "builds"
        case bundleid = "bundleId"
        case ciproduct = "ciProduct"
        case contentrightsdeclaration = "contentRightsDeclaration"
        case enduserlicenseagreement = "endUserLicenseAgreement"
        case gamecenterenabledversions = "gameCenterEnabledVersions"
        case inapppurchases = "inAppPurchases"
        case isoreverwasmadeforkids = "isOrEverWasMadeForKids"
        case name = "name"
        case perfpowermetrics = "perfPowerMetrics"
        case preorder = "preOrder"
        case prereleaseversions = "preReleaseVersions"
        case pricepoints = "pricePoints"
        case prices = "prices"
        case primarylocale = "primaryLocale"
        case reviewsubmissions = "reviewSubmissions"
        case sku = "sku"
        case subscriptionstatusurl = "subscriptionStatusUrl"
        case subscriptionstatusurlforsandbox = "subscriptionStatusUrlForSandbox"
        case subscriptionstatusurlversion = "subscriptionStatusUrlVersion"
        case subscriptionstatusurlversionforsandbox = "subscriptionStatusUrlVersionForSandbox"
    }

    /**
     * enum for parameter include
     */
    public enum Include_appsAppCustomProductPagesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appcustomproductpageversions = "appCustomProductPageVersions"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter filterVisible: (query) filter by attribute &#39;visible&#39; (optional)
     - parameter fieldsAppCustomProductPages: (query) the fields to include for returned resources of type appCustomProductPages (optional)
     - parameter fieldsAppCustomProductPageVersions: (query) the fields to include for returned resources of type appCustomProductPageVersions (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitAppCustomProductPageVersions: (query) maximum number of related appCustomProductPageVersions returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: AppCustomProductPagesResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsAppCustomProductPagesGetToManyRelated(id: String, filterVisible: [String]? = nil, fieldsAppCustomProductPages: [FieldsAppCustomProductPages_appsAppCustomProductPagesGetToManyRelated]? = nil, fieldsAppCustomProductPageVersions: [FieldsAppCustomProductPageVersions_appsAppCustomProductPagesGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsAppCustomProductPagesGetToManyRelated]? = nil, limit: Int? = nil, limitAppCustomProductPageVersions: Int? = nil, include: [Include_appsAppCustomProductPagesGetToManyRelated]? = nil) async throws -> AppCustomProductPagesResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsAppCustomProductPagesGetToManyRelatedWithRequestBuilder(id: id, filterVisible: filterVisible, fieldsAppCustomProductPages: fieldsAppCustomProductPages, fieldsAppCustomProductPageVersions: fieldsAppCustomProductPageVersions, fieldsApps: fieldsApps, limit: limit, limitAppCustomProductPageVersions: limitAppCustomProductPageVersions, include: include).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: AppCustomProductPagesResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsAppCustomProductPagesGetToManyRelated(urlString: String) async throws -> AppCustomProductPagesResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsAppCustomProductPagesGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/appCustomProductPages
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter filterVisible: (query) filter by attribute &#39;visible&#39; (optional)
     - parameter fieldsAppCustomProductPages: (query) the fields to include for returned resources of type appCustomProductPages (optional)
     - parameter fieldsAppCustomProductPageVersions: (query) the fields to include for returned resources of type appCustomProductPageVersions (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitAppCustomProductPageVersions: (query) maximum number of related appCustomProductPageVersions returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: RequestBuilder<AppCustomProductPagesResponse> 
     */
    open class func appsAppCustomProductPagesGetToManyRelatedWithRequestBuilder(id: String, filterVisible: [String]? = nil, fieldsAppCustomProductPages: [FieldsAppCustomProductPages_appsAppCustomProductPagesGetToManyRelated]? = nil, fieldsAppCustomProductPageVersions: [FieldsAppCustomProductPageVersions_appsAppCustomProductPagesGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsAppCustomProductPagesGetToManyRelated]? = nil, limit: Int? = nil, limitAppCustomProductPageVersions: Int? = nil, include: [Include_appsAppCustomProductPagesGetToManyRelated]? = nil) -> RequestBuilder<AppCustomProductPagesResponse> {
        var localVariablePath = "/v1/apps/{id}/appCustomProductPages"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "filter[visible]": filterVisible?.encodeToJSON(),
            "fields[appCustomProductPages]": fieldsAppCustomProductPages?.encodeToJSON(),
            "fields[appCustomProductPageVersions]": fieldsAppCustomProductPageVersions?.encodeToJSON(),
            "fields[apps]": fieldsApps?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "limit[appCustomProductPageVersions]": limitAppCustomProductPageVersions?.encodeToJSON(),
            "include": include?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AppCustomProductPagesResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/appCustomProductPages
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<AppCustomProductPagesResponse> 
     */
    open class func appsAppCustomProductPagesGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<AppCustomProductPagesResponse> {
        let localVariableRequestBuilder: RequestBuilder<AppCustomProductPagesResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter filterEventState
     */
    public enum FilterEventState_appsAppEventsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case draft = "DRAFT"
        case readyForReview = "READY_FOR_REVIEW"
        case waitingForReview = "WAITING_FOR_REVIEW"
        case inReview = "IN_REVIEW"
        case rejected = "REJECTED"
        case accepted = "ACCEPTED"
        case approved = "APPROVED"
        case published = "PUBLISHED"
        case past = "PAST"
        case archived = "ARCHIVED"
    }

    /**
     * enum for parameter fieldsAppEventLocalizations
     */
    public enum FieldsAppEventLocalizations_appsAppEventsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appevent = "appEvent"
        case appeventscreenshots = "appEventScreenshots"
        case appeventvideoclips = "appEventVideoClips"
        case locale = "locale"
        case longdescription = "longDescription"
        case name = "name"
        case shortdescription = "shortDescription"
    }

    /**
     * enum for parameter fieldsAppEvents
     */
    public enum FieldsAppEvents_appsAppEventsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case archivedterritoryschedules = "archivedTerritorySchedules"
        case badge = "badge"
        case deeplink = "deepLink"
        case eventstate = "eventState"
        case localizations = "localizations"
        case primarylocale = "primaryLocale"
        case priority = "priority"
        case purchaserequirement = "purchaseRequirement"
        case purpose = "purpose"
        case referencename = "referenceName"
        case territoryschedules = "territorySchedules"
    }

    /**
     * enum for parameter include
     */
    public enum Include_appsAppEventsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case localizations = "localizations"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter filterEventState: (query) filter by attribute &#39;eventState&#39; (optional)
     - parameter filterId: (query) filter by id(s) (optional)
     - parameter fieldsAppEventLocalizations: (query) the fields to include for returned resources of type appEventLocalizations (optional)
     - parameter fieldsAppEvents: (query) the fields to include for returned resources of type appEvents (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitLocalizations: (query) maximum number of related localizations returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: AppEventsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsAppEventsGetToManyRelated(id: String, filterEventState: [FilterEventState_appsAppEventsGetToManyRelated]? = nil, filterId: [String]? = nil, fieldsAppEventLocalizations: [FieldsAppEventLocalizations_appsAppEventsGetToManyRelated]? = nil, fieldsAppEvents: [FieldsAppEvents_appsAppEventsGetToManyRelated]? = nil, limit: Int? = nil, limitLocalizations: Int? = nil, include: [Include_appsAppEventsGetToManyRelated]? = nil) async throws -> AppEventsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsAppEventsGetToManyRelatedWithRequestBuilder(id: id, filterEventState: filterEventState, filterId: filterId, fieldsAppEventLocalizations: fieldsAppEventLocalizations, fieldsAppEvents: fieldsAppEvents, limit: limit, limitLocalizations: limitLocalizations, include: include).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: AppEventsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsAppEventsGetToManyRelated(urlString: String) async throws -> AppEventsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsAppEventsGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/appEvents
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter filterEventState: (query) filter by attribute &#39;eventState&#39; (optional)
     - parameter filterId: (query) filter by id(s) (optional)
     - parameter fieldsAppEventLocalizations: (query) the fields to include for returned resources of type appEventLocalizations (optional)
     - parameter fieldsAppEvents: (query) the fields to include for returned resources of type appEvents (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitLocalizations: (query) maximum number of related localizations returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: RequestBuilder<AppEventsResponse> 
     */
    open class func appsAppEventsGetToManyRelatedWithRequestBuilder(id: String, filterEventState: [FilterEventState_appsAppEventsGetToManyRelated]? = nil, filterId: [String]? = nil, fieldsAppEventLocalizations: [FieldsAppEventLocalizations_appsAppEventsGetToManyRelated]? = nil, fieldsAppEvents: [FieldsAppEvents_appsAppEventsGetToManyRelated]? = nil, limit: Int? = nil, limitLocalizations: Int? = nil, include: [Include_appsAppEventsGetToManyRelated]? = nil) -> RequestBuilder<AppEventsResponse> {
        var localVariablePath = "/v1/apps/{id}/appEvents"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "filter[eventState]": filterEventState?.encodeToJSON(),
            "filter[id]": filterId?.encodeToJSON(),
            "fields[appEventLocalizations]": fieldsAppEventLocalizations?.encodeToJSON(),
            "fields[appEvents]": fieldsAppEvents?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "limit[localizations]": limitLocalizations?.encodeToJSON(),
            "include": include?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AppEventsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/appEvents
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<AppEventsResponse> 
     */
    open class func appsAppEventsGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<AppEventsResponse> {
        let localVariableRequestBuilder: RequestBuilder<AppEventsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsAgeRatingDeclarations
     */
    public enum FieldsAgeRatingDeclarations_appsAppInfosGetToManyRelated: String, CaseIterable, JSONEncodable {
        case alcoholtobaccoordruguseorreferences = "alcoholTobaccoOrDrugUseOrReferences"
        case contests = "contests"
        case gambling = "gambling"
        case gamblingandcontests = "gamblingAndContests"
        case gamblingsimulated = "gamblingSimulated"
        case horrororfearthemes = "horrorOrFearThemes"
        case kidsageband = "kidsAgeBand"
        case matureorsuggestivethemes = "matureOrSuggestiveThemes"
        case medicalortreatmentinformation = "medicalOrTreatmentInformation"
        case profanityorcrudehumor = "profanityOrCrudeHumor"
        case seventeenplus = "seventeenPlus"
        case sexualcontentgraphicandnudity = "sexualContentGraphicAndNudity"
        case sexualcontentornudity = "sexualContentOrNudity"
        case unrestrictedwebaccess = "unrestrictedWebAccess"
        case violencecartoonorfantasy = "violenceCartoonOrFantasy"
        case violencerealistic = "violenceRealistic"
        case violencerealisticprolongedgraphicorsadistic = "violenceRealisticProlongedGraphicOrSadistic"
    }

    /**
     * enum for parameter fieldsAppInfos
     */
    public enum FieldsAppInfos_appsAppInfosGetToManyRelated: String, CaseIterable, JSONEncodable {
        case ageratingdeclaration = "ageRatingDeclaration"
        case app = "app"
        case appinfolocalizations = "appInfoLocalizations"
        case appstoreagerating = "appStoreAgeRating"
        case appstorestate = "appStoreState"
        case brazilagerating = "brazilAgeRating"
        case kidsageband = "kidsAgeBand"
        case primarycategory = "primaryCategory"
        case primarysubcategoryone = "primarySubcategoryOne"
        case primarysubcategorytwo = "primarySubcategoryTwo"
        case secondarycategory = "secondaryCategory"
        case secondarysubcategoryone = "secondarySubcategoryOne"
        case secondarysubcategorytwo = "secondarySubcategoryTwo"
    }

    /**
     * enum for parameter fieldsAppInfoLocalizations
     */
    public enum FieldsAppInfoLocalizations_appsAppInfosGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appinfo = "appInfo"
        case locale = "locale"
        case name = "name"
        case privacychoicesurl = "privacyChoicesUrl"
        case privacypolicytext = "privacyPolicyText"
        case privacypolicyurl = "privacyPolicyUrl"
        case subtitle = "subtitle"
    }

    /**
     * enum for parameter fieldsAppCategories
     */
    public enum FieldsAppCategories_appsAppInfosGetToManyRelated: String, CaseIterable, JSONEncodable {
        case parent = "parent"
        case platforms = "platforms"
        case subcategories = "subcategories"
    }

    /**
     * enum for parameter fieldsApps
     */
    public enum FieldsApps_appsAppInfosGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appclips = "appClips"
        case appcustomproductpages = "appCustomProductPages"
        case appevents = "appEvents"
        case appinfos = "appInfos"
        case appstoreversions = "appStoreVersions"
        case availableinnewterritories = "availableInNewTerritories"
        case availableterritories = "availableTerritories"
        case betaapplocalizations = "betaAppLocalizations"
        case betaappreviewdetail = "betaAppReviewDetail"
        case betagroups = "betaGroups"
        case betalicenseagreement = "betaLicenseAgreement"
        case betatesters = "betaTesters"
        case builds = "builds"
        case bundleid = "bundleId"
        case ciproduct = "ciProduct"
        case contentrightsdeclaration = "contentRightsDeclaration"
        case enduserlicenseagreement = "endUserLicenseAgreement"
        case gamecenterenabledversions = "gameCenterEnabledVersions"
        case inapppurchases = "inAppPurchases"
        case isoreverwasmadeforkids = "isOrEverWasMadeForKids"
        case name = "name"
        case perfpowermetrics = "perfPowerMetrics"
        case preorder = "preOrder"
        case prereleaseversions = "preReleaseVersions"
        case pricepoints = "pricePoints"
        case prices = "prices"
        case primarylocale = "primaryLocale"
        case reviewsubmissions = "reviewSubmissions"
        case sku = "sku"
        case subscriptionstatusurl = "subscriptionStatusUrl"
        case subscriptionstatusurlforsandbox = "subscriptionStatusUrlForSandbox"
        case subscriptionstatusurlversion = "subscriptionStatusUrlVersion"
        case subscriptionstatusurlversionforsandbox = "subscriptionStatusUrlVersionForSandbox"
    }

    /**
     * enum for parameter include
     */
    public enum Include_appsAppInfosGetToManyRelated: String, CaseIterable, JSONEncodable {
        case ageratingdeclaration = "ageRatingDeclaration"
        case app = "app"
        case appinfolocalizations = "appInfoLocalizations"
        case primarycategory = "primaryCategory"
        case primarysubcategoryone = "primarySubcategoryOne"
        case primarysubcategorytwo = "primarySubcategoryTwo"
        case secondarycategory = "secondaryCategory"
        case secondarysubcategoryone = "secondarySubcategoryOne"
        case secondarysubcategorytwo = "secondarySubcategoryTwo"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsAgeRatingDeclarations: (query) the fields to include for returned resources of type ageRatingDeclarations (optional)
     - parameter fieldsAppInfos: (query) the fields to include for returned resources of type appInfos (optional)
     - parameter fieldsAppInfoLocalizations: (query) the fields to include for returned resources of type appInfoLocalizations (optional)
     - parameter fieldsAppCategories: (query) the fields to include for returned resources of type appCategories (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitAppInfoLocalizations: (query) maximum number of related appInfoLocalizations returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: AppInfosResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsAppInfosGetToManyRelated(id: String, fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations_appsAppInfosGetToManyRelated]? = nil, fieldsAppInfos: [FieldsAppInfos_appsAppInfosGetToManyRelated]? = nil, fieldsAppInfoLocalizations: [FieldsAppInfoLocalizations_appsAppInfosGetToManyRelated]? = nil, fieldsAppCategories: [FieldsAppCategories_appsAppInfosGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsAppInfosGetToManyRelated]? = nil, limit: Int? = nil, limitAppInfoLocalizations: Int? = nil, include: [Include_appsAppInfosGetToManyRelated]? = nil) async throws -> AppInfosResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsAppInfosGetToManyRelatedWithRequestBuilder(id: id, fieldsAgeRatingDeclarations: fieldsAgeRatingDeclarations, fieldsAppInfos: fieldsAppInfos, fieldsAppInfoLocalizations: fieldsAppInfoLocalizations, fieldsAppCategories: fieldsAppCategories, fieldsApps: fieldsApps, limit: limit, limitAppInfoLocalizations: limitAppInfoLocalizations, include: include).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: AppInfosResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsAppInfosGetToManyRelated(urlString: String) async throws -> AppInfosResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsAppInfosGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/appInfos
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsAgeRatingDeclarations: (query) the fields to include for returned resources of type ageRatingDeclarations (optional)
     - parameter fieldsAppInfos: (query) the fields to include for returned resources of type appInfos (optional)
     - parameter fieldsAppInfoLocalizations: (query) the fields to include for returned resources of type appInfoLocalizations (optional)
     - parameter fieldsAppCategories: (query) the fields to include for returned resources of type appCategories (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitAppInfoLocalizations: (query) maximum number of related appInfoLocalizations returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: RequestBuilder<AppInfosResponse> 
     */
    open class func appsAppInfosGetToManyRelatedWithRequestBuilder(id: String, fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations_appsAppInfosGetToManyRelated]? = nil, fieldsAppInfos: [FieldsAppInfos_appsAppInfosGetToManyRelated]? = nil, fieldsAppInfoLocalizations: [FieldsAppInfoLocalizations_appsAppInfosGetToManyRelated]? = nil, fieldsAppCategories: [FieldsAppCategories_appsAppInfosGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsAppInfosGetToManyRelated]? = nil, limit: Int? = nil, limitAppInfoLocalizations: Int? = nil, include: [Include_appsAppInfosGetToManyRelated]? = nil) -> RequestBuilder<AppInfosResponse> {
        var localVariablePath = "/v1/apps/{id}/appInfos"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[ageRatingDeclarations]": fieldsAgeRatingDeclarations?.encodeToJSON(),
            "fields[appInfos]": fieldsAppInfos?.encodeToJSON(),
            "fields[appInfoLocalizations]": fieldsAppInfoLocalizations?.encodeToJSON(),
            "fields[appCategories]": fieldsAppCategories?.encodeToJSON(),
            "fields[apps]": fieldsApps?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "limit[appInfoLocalizations]": limitAppInfoLocalizations?.encodeToJSON(),
            "include": include?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AppInfosResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/appInfos
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<AppInfosResponse> 
     */
    open class func appsAppInfosGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<AppInfosResponse> {
        let localVariableRequestBuilder: RequestBuilder<AppInfosResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter filterAppStoreState
     */
    public enum FilterAppStoreState_appsAppStoreVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case accepted = "ACCEPTED"
        case developerRemovedFromSale = "DEVELOPER_REMOVED_FROM_SALE"
        case developerRejected = "DEVELOPER_REJECTED"
        case inReview = "IN_REVIEW"
        case invalidBinary = "INVALID_BINARY"
        case metadataRejected = "METADATA_REJECTED"
        case pendingAppleRelease = "PENDING_APPLE_RELEASE"
        case pendingContract = "PENDING_CONTRACT"
        case pendingDeveloperRelease = "PENDING_DEVELOPER_RELEASE"
        case prepareForSubmission = "PREPARE_FOR_SUBMISSION"
        case preorderReadyForSale = "PREORDER_READY_FOR_SALE"
        case processingForAppStore = "PROCESSING_FOR_APP_STORE"
        case readyForReview = "READY_FOR_REVIEW"
        case readyForSale = "READY_FOR_SALE"
        case rejected = "REJECTED"
        case removedFromSale = "REMOVED_FROM_SALE"
        case waitingForExportCompliance = "WAITING_FOR_EXPORT_COMPLIANCE"
        case waitingForReview = "WAITING_FOR_REVIEW"
        case replacedWithNewVersion = "REPLACED_WITH_NEW_VERSION"
    }

    /**
     * enum for parameter filterPlatform
     */
    public enum FilterPlatform_appsAppStoreVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case ios = "IOS"
        case macOs = "MAC_OS"
        case tvOs = "TV_OS"
    }

    /**
     * enum for parameter fieldsAppStoreVersionExperiments
     */
    public enum FieldsAppStoreVersionExperiments_appsAppStoreVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appstoreversion = "appStoreVersion"
        case appstoreversionexperimenttreatments = "appStoreVersionExperimentTreatments"
        case enddate = "endDate"
        case name = "name"
        case reviewrequired = "reviewRequired"
        case startdate = "startDate"
        case started = "started"
        case state = "state"
        case trafficproportion = "trafficProportion"
    }

    /**
     * enum for parameter fieldsAgeRatingDeclarations
     */
    public enum FieldsAgeRatingDeclarations_appsAppStoreVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case alcoholtobaccoordruguseorreferences = "alcoholTobaccoOrDrugUseOrReferences"
        case contests = "contests"
        case gambling = "gambling"
        case gamblingandcontests = "gamblingAndContests"
        case gamblingsimulated = "gamblingSimulated"
        case horrororfearthemes = "horrorOrFearThemes"
        case kidsageband = "kidsAgeBand"
        case matureorsuggestivethemes = "matureOrSuggestiveThemes"
        case medicalortreatmentinformation = "medicalOrTreatmentInformation"
        case profanityorcrudehumor = "profanityOrCrudeHumor"
        case seventeenplus = "seventeenPlus"
        case sexualcontentgraphicandnudity = "sexualContentGraphicAndNudity"
        case sexualcontentornudity = "sexualContentOrNudity"
        case unrestrictedwebaccess = "unrestrictedWebAccess"
        case violencecartoonorfantasy = "violenceCartoonOrFantasy"
        case violencerealistic = "violenceRealistic"
        case violencerealisticprolongedgraphicorsadistic = "violenceRealisticProlongedGraphicOrSadistic"
    }

    /**
     * enum for parameter fieldsAppStoreVersionSubmissions
     */
    public enum FieldsAppStoreVersionSubmissions_appsAppStoreVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appstoreversion = "appStoreVersion"
    }

    /**
     * enum for parameter fieldsAppStoreReviewDetails
     */
    public enum FieldsAppStoreReviewDetails_appsAppStoreVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appstorereviewattachments = "appStoreReviewAttachments"
        case appstoreversion = "appStoreVersion"
        case contactemail = "contactEmail"
        case contactfirstname = "contactFirstName"
        case contactlastname = "contactLastName"
        case contactphone = "contactPhone"
        case demoaccountname = "demoAccountName"
        case demoaccountpassword = "demoAccountPassword"
        case demoaccountrequired = "demoAccountRequired"
        case notes = "notes"
    }

    /**
     * enum for parameter fieldsAppStoreVersions
     */
    public enum FieldsAppStoreVersions_appsAppStoreVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case ageratingdeclaration = "ageRatingDeclaration"
        case app = "app"
        case appclipdefaultexperience = "appClipDefaultExperience"
        case appstorereviewdetail = "appStoreReviewDetail"
        case appstorestate = "appStoreState"
        case appstoreversionexperiments = "appStoreVersionExperiments"
        case appstoreversionlocalizations = "appStoreVersionLocalizations"
        case appstoreversionphasedrelease = "appStoreVersionPhasedRelease"
        case appstoreversionsubmission = "appStoreVersionSubmission"
        case build = "build"
        case copyright = "copyright"
        case createddate = "createdDate"
        case downloadable = "downloadable"
        case earliestreleasedate = "earliestReleaseDate"
        case idfadeclaration = "idfaDeclaration"
        case platform = "platform"
        case releasetype = "releaseType"
        case routingappcoverage = "routingAppCoverage"
        case usesidfa = "usesIdfa"
        case versionstring = "versionString"
    }

    /**
     * enum for parameter fieldsIdfaDeclarations
     */
    public enum FieldsIdfaDeclarations_appsAppStoreVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appstoreversion = "appStoreVersion"
        case attributesactionwithpreviousad = "attributesActionWithPreviousAd"
        case attributesappinstallationtopreviousad = "attributesAppInstallationToPreviousAd"
        case honorslimitedadtracking = "honorsLimitedAdTracking"
        case servesads = "servesAds"
    }

    /**
     * enum for parameter fieldsApps
     */
    public enum FieldsApps_appsAppStoreVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appclips = "appClips"
        case appcustomproductpages = "appCustomProductPages"
        case appevents = "appEvents"
        case appinfos = "appInfos"
        case appstoreversions = "appStoreVersions"
        case availableinnewterritories = "availableInNewTerritories"
        case availableterritories = "availableTerritories"
        case betaapplocalizations = "betaAppLocalizations"
        case betaappreviewdetail = "betaAppReviewDetail"
        case betagroups = "betaGroups"
        case betalicenseagreement = "betaLicenseAgreement"
        case betatesters = "betaTesters"
        case builds = "builds"
        case bundleid = "bundleId"
        case ciproduct = "ciProduct"
        case contentrightsdeclaration = "contentRightsDeclaration"
        case enduserlicenseagreement = "endUserLicenseAgreement"
        case gamecenterenabledversions = "gameCenterEnabledVersions"
        case inapppurchases = "inAppPurchases"
        case isoreverwasmadeforkids = "isOrEverWasMadeForKids"
        case name = "name"
        case perfpowermetrics = "perfPowerMetrics"
        case preorder = "preOrder"
        case prereleaseversions = "preReleaseVersions"
        case pricepoints = "pricePoints"
        case prices = "prices"
        case primarylocale = "primaryLocale"
        case reviewsubmissions = "reviewSubmissions"
        case sku = "sku"
        case subscriptionstatusurl = "subscriptionStatusUrl"
        case subscriptionstatusurlforsandbox = "subscriptionStatusUrlForSandbox"
        case subscriptionstatusurlversion = "subscriptionStatusUrlVersion"
        case subscriptionstatusurlversionforsandbox = "subscriptionStatusUrlVersionForSandbox"
    }

    /**
     * enum for parameter fieldsRoutingAppCoverages
     */
    public enum FieldsRoutingAppCoverages_appsAppStoreVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appstoreversion = "appStoreVersion"
        case assetdeliverystate = "assetDeliveryState"
        case filename = "fileName"
        case filesize = "fileSize"
        case sourcefilechecksum = "sourceFileChecksum"
        case uploadoperations = "uploadOperations"
        case uploaded = "uploaded"
    }

    /**
     * enum for parameter fieldsAppClipDefaultExperiences
     */
    public enum FieldsAppClipDefaultExperiences_appsAppStoreVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case action = "action"
        case appclip = "appClip"
        case appclipappstorereviewdetail = "appClipAppStoreReviewDetail"
        case appclipdefaultexperiencelocalizations = "appClipDefaultExperienceLocalizations"
        case appclipdefaultexperiencetemplate = "appClipDefaultExperienceTemplate"
        case releasewithappstoreversion = "releaseWithAppStoreVersion"
    }

    /**
     * enum for parameter fieldsAppStoreVersionPhasedReleases
     */
    public enum FieldsAppStoreVersionPhasedReleases_appsAppStoreVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appstoreversion = "appStoreVersion"
        case currentdaynumber = "currentDayNumber"
        case phasedreleasestate = "phasedReleaseState"
        case startdate = "startDate"
        case totalpauseduration = "totalPauseDuration"
    }

    /**
     * enum for parameter fieldsBuilds
     */
    public enum FieldsBuilds_appsAppStoreVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appencryptiondeclaration = "appEncryptionDeclaration"
        case appstoreversion = "appStoreVersion"
        case betaappreviewsubmission = "betaAppReviewSubmission"
        case betabuildlocalizations = "betaBuildLocalizations"
        case betagroups = "betaGroups"
        case buildaudiencetype = "buildAudienceType"
        case buildbetadetail = "buildBetaDetail"
        case buildbundles = "buildBundles"
        case computedminmacosversion = "computedMinMacOsVersion"
        case diagnosticsignatures = "diagnosticSignatures"
        case expirationdate = "expirationDate"
        case expired = "expired"
        case iconassettoken = "iconAssetToken"
        case icons = "icons"
        case individualtesters = "individualTesters"
        case lsminimumsystemversion = "lsMinimumSystemVersion"
        case minosversion = "minOsVersion"
        case perfpowermetrics = "perfPowerMetrics"
        case prereleaseversion = "preReleaseVersion"
        case processingstate = "processingState"
        case uploadeddate = "uploadedDate"
        case usesnonexemptencryption = "usesNonExemptEncryption"
        case version = "version"
    }

    /**
     * enum for parameter fieldsAppStoreVersionLocalizations
     */
    public enum FieldsAppStoreVersionLocalizations_appsAppStoreVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case apppreviewsets = "appPreviewSets"
        case appscreenshotsets = "appScreenshotSets"
        case appstoreversion = "appStoreVersion"
        case description = "description"
        case keywords = "keywords"
        case locale = "locale"
        case marketingurl = "marketingUrl"
        case promotionaltext = "promotionalText"
        case supporturl = "supportUrl"
        case whatsnew = "whatsNew"
    }

    /**
     * enum for parameter include
     */
    public enum Include_appsAppStoreVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case ageratingdeclaration = "ageRatingDeclaration"
        case app = "app"
        case appclipdefaultexperience = "appClipDefaultExperience"
        case appstorereviewdetail = "appStoreReviewDetail"
        case appstoreversionexperiments = "appStoreVersionExperiments"
        case appstoreversionlocalizations = "appStoreVersionLocalizations"
        case appstoreversionphasedrelease = "appStoreVersionPhasedRelease"
        case appstoreversionsubmission = "appStoreVersionSubmission"
        case build = "build"
        case idfadeclaration = "idfaDeclaration"
        case routingappcoverage = "routingAppCoverage"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter filterAppStoreState: (query) filter by attribute &#39;appStoreState&#39; (optional)
     - parameter filterPlatform: (query) filter by attribute &#39;platform&#39; (optional)
     - parameter filterVersionString: (query) filter by attribute &#39;versionString&#39; (optional)
     - parameter filterId: (query) filter by id(s) (optional)
     - parameter fieldsAppStoreVersionExperiments: (query) the fields to include for returned resources of type appStoreVersionExperiments (optional)
     - parameter fieldsAgeRatingDeclarations: (query) the fields to include for returned resources of type ageRatingDeclarations (optional)
     - parameter fieldsAppStoreVersionSubmissions: (query) the fields to include for returned resources of type appStoreVersionSubmissions (optional)
     - parameter fieldsAppStoreReviewDetails: (query) the fields to include for returned resources of type appStoreReviewDetails (optional)
     - parameter fieldsAppStoreVersions: (query) the fields to include for returned resources of type appStoreVersions (optional)
     - parameter fieldsIdfaDeclarations: (query) the fields to include for returned resources of type idfaDeclarations (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter fieldsRoutingAppCoverages: (query) the fields to include for returned resources of type routingAppCoverages (optional)
     - parameter fieldsAppClipDefaultExperiences: (query) the fields to include for returned resources of type appClipDefaultExperiences (optional)
     - parameter fieldsAppStoreVersionPhasedReleases: (query) the fields to include for returned resources of type appStoreVersionPhasedReleases (optional)
     - parameter fieldsBuilds: (query) the fields to include for returned resources of type builds (optional)
     - parameter fieldsAppStoreVersionLocalizations: (query) the fields to include for returned resources of type appStoreVersionLocalizations (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitAppStoreVersionLocalizations: (query) maximum number of related appStoreVersionLocalizations returned (when they are included) (optional)
     - parameter limitAppStoreVersionExperiments: (query) maximum number of related appStoreVersionExperiments returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: AppStoreVersionsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsAppStoreVersionsGetToManyRelated(id: String, filterAppStoreState: [FilterAppStoreState_appsAppStoreVersionsGetToManyRelated]? = nil, filterPlatform: [FilterPlatform_appsAppStoreVersionsGetToManyRelated]? = nil, filterVersionString: [String]? = nil, filterId: [String]? = nil, fieldsAppStoreVersionExperiments: [FieldsAppStoreVersionExperiments_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsAppStoreVersionSubmissions: [FieldsAppStoreVersionSubmissions_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsAppStoreReviewDetails: [FieldsAppStoreReviewDetails_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsAppStoreVersions: [FieldsAppStoreVersions_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsIdfaDeclarations: [FieldsIdfaDeclarations_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsRoutingAppCoverages: [FieldsRoutingAppCoverages_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsAppClipDefaultExperiences: [FieldsAppClipDefaultExperiences_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsAppStoreVersionPhasedReleases: [FieldsAppStoreVersionPhasedReleases_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsBuilds: [FieldsBuilds_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsAppStoreVersionLocalizations: [FieldsAppStoreVersionLocalizations_appsAppStoreVersionsGetToManyRelated]? = nil, limit: Int? = nil, limitAppStoreVersionLocalizations: Int? = nil, limitAppStoreVersionExperiments: Int? = nil, include: [Include_appsAppStoreVersionsGetToManyRelated]? = nil) async throws -> AppStoreVersionsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsAppStoreVersionsGetToManyRelatedWithRequestBuilder(id: id, filterAppStoreState: filterAppStoreState, filterPlatform: filterPlatform, filterVersionString: filterVersionString, filterId: filterId, fieldsAppStoreVersionExperiments: fieldsAppStoreVersionExperiments, fieldsAgeRatingDeclarations: fieldsAgeRatingDeclarations, fieldsAppStoreVersionSubmissions: fieldsAppStoreVersionSubmissions, fieldsAppStoreReviewDetails: fieldsAppStoreReviewDetails, fieldsAppStoreVersions: fieldsAppStoreVersions, fieldsIdfaDeclarations: fieldsIdfaDeclarations, fieldsApps: fieldsApps, fieldsRoutingAppCoverages: fieldsRoutingAppCoverages, fieldsAppClipDefaultExperiences: fieldsAppClipDefaultExperiences, fieldsAppStoreVersionPhasedReleases: fieldsAppStoreVersionPhasedReleases, fieldsBuilds: fieldsBuilds, fieldsAppStoreVersionLocalizations: fieldsAppStoreVersionLocalizations, limit: limit, limitAppStoreVersionLocalizations: limitAppStoreVersionLocalizations, limitAppStoreVersionExperiments: limitAppStoreVersionExperiments, include: include).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: AppStoreVersionsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsAppStoreVersionsGetToManyRelated(urlString: String) async throws -> AppStoreVersionsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsAppStoreVersionsGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/appStoreVersions
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter filterAppStoreState: (query) filter by attribute &#39;appStoreState&#39; (optional)
     - parameter filterPlatform: (query) filter by attribute &#39;platform&#39; (optional)
     - parameter filterVersionString: (query) filter by attribute &#39;versionString&#39; (optional)
     - parameter filterId: (query) filter by id(s) (optional)
     - parameter fieldsAppStoreVersionExperiments: (query) the fields to include for returned resources of type appStoreVersionExperiments (optional)
     - parameter fieldsAgeRatingDeclarations: (query) the fields to include for returned resources of type ageRatingDeclarations (optional)
     - parameter fieldsAppStoreVersionSubmissions: (query) the fields to include for returned resources of type appStoreVersionSubmissions (optional)
     - parameter fieldsAppStoreReviewDetails: (query) the fields to include for returned resources of type appStoreReviewDetails (optional)
     - parameter fieldsAppStoreVersions: (query) the fields to include for returned resources of type appStoreVersions (optional)
     - parameter fieldsIdfaDeclarations: (query) the fields to include for returned resources of type idfaDeclarations (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter fieldsRoutingAppCoverages: (query) the fields to include for returned resources of type routingAppCoverages (optional)
     - parameter fieldsAppClipDefaultExperiences: (query) the fields to include for returned resources of type appClipDefaultExperiences (optional)
     - parameter fieldsAppStoreVersionPhasedReleases: (query) the fields to include for returned resources of type appStoreVersionPhasedReleases (optional)
     - parameter fieldsBuilds: (query) the fields to include for returned resources of type builds (optional)
     - parameter fieldsAppStoreVersionLocalizations: (query) the fields to include for returned resources of type appStoreVersionLocalizations (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitAppStoreVersionLocalizations: (query) maximum number of related appStoreVersionLocalizations returned (when they are included) (optional)
     - parameter limitAppStoreVersionExperiments: (query) maximum number of related appStoreVersionExperiments returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: RequestBuilder<AppStoreVersionsResponse> 
     */
    open class func appsAppStoreVersionsGetToManyRelatedWithRequestBuilder(id: String, filterAppStoreState: [FilterAppStoreState_appsAppStoreVersionsGetToManyRelated]? = nil, filterPlatform: [FilterPlatform_appsAppStoreVersionsGetToManyRelated]? = nil, filterVersionString: [String]? = nil, filterId: [String]? = nil, fieldsAppStoreVersionExperiments: [FieldsAppStoreVersionExperiments_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsAgeRatingDeclarations: [FieldsAgeRatingDeclarations_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsAppStoreVersionSubmissions: [FieldsAppStoreVersionSubmissions_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsAppStoreReviewDetails: [FieldsAppStoreReviewDetails_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsAppStoreVersions: [FieldsAppStoreVersions_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsIdfaDeclarations: [FieldsIdfaDeclarations_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsRoutingAppCoverages: [FieldsRoutingAppCoverages_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsAppClipDefaultExperiences: [FieldsAppClipDefaultExperiences_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsAppStoreVersionPhasedReleases: [FieldsAppStoreVersionPhasedReleases_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsBuilds: [FieldsBuilds_appsAppStoreVersionsGetToManyRelated]? = nil, fieldsAppStoreVersionLocalizations: [FieldsAppStoreVersionLocalizations_appsAppStoreVersionsGetToManyRelated]? = nil, limit: Int? = nil, limitAppStoreVersionLocalizations: Int? = nil, limitAppStoreVersionExperiments: Int? = nil, include: [Include_appsAppStoreVersionsGetToManyRelated]? = nil) -> RequestBuilder<AppStoreVersionsResponse> {
        var localVariablePath = "/v1/apps/{id}/appStoreVersions"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "filter[appStoreState]": filterAppStoreState?.encodeToJSON(),
            "filter[platform]": filterPlatform?.encodeToJSON(),
            "filter[versionString]": filterVersionString?.encodeToJSON(),
            "filter[id]": filterId?.encodeToJSON(),
            "fields[appStoreVersionExperiments]": fieldsAppStoreVersionExperiments?.encodeToJSON(),
            "fields[ageRatingDeclarations]": fieldsAgeRatingDeclarations?.encodeToJSON(),
            "fields[appStoreVersionSubmissions]": fieldsAppStoreVersionSubmissions?.encodeToJSON(),
            "fields[appStoreReviewDetails]": fieldsAppStoreReviewDetails?.encodeToJSON(),
            "fields[appStoreVersions]": fieldsAppStoreVersions?.encodeToJSON(),
            "fields[idfaDeclarations]": fieldsIdfaDeclarations?.encodeToJSON(),
            "fields[apps]": fieldsApps?.encodeToJSON(),
            "fields[routingAppCoverages]": fieldsRoutingAppCoverages?.encodeToJSON(),
            "fields[appClipDefaultExperiences]": fieldsAppClipDefaultExperiences?.encodeToJSON(),
            "fields[appStoreVersionPhasedReleases]": fieldsAppStoreVersionPhasedReleases?.encodeToJSON(),
            "fields[builds]": fieldsBuilds?.encodeToJSON(),
            "fields[appStoreVersionLocalizations]": fieldsAppStoreVersionLocalizations?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "limit[appStoreVersionLocalizations]": limitAppStoreVersionLocalizations?.encodeToJSON(),
            "limit[appStoreVersionExperiments]": limitAppStoreVersionExperiments?.encodeToJSON(),
            "include": include?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AppStoreVersionsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/appStoreVersions
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<AppStoreVersionsResponse> 
     */
    open class func appsAppStoreVersionsGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<AppStoreVersionsResponse> {
        let localVariableRequestBuilder: RequestBuilder<AppStoreVersionsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsTerritories
     */
    public enum FieldsTerritories_appsAvailableTerritoriesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case currency = "currency"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsTerritories: (query) the fields to include for returned resources of type territories (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - returns: TerritoriesResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsAvailableTerritoriesGetToManyRelated(id: String, fieldsTerritories: [FieldsTerritories_appsAvailableTerritoriesGetToManyRelated]? = nil, limit: Int? = nil) async throws -> TerritoriesResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsAvailableTerritoriesGetToManyRelatedWithRequestBuilder(id: id, fieldsTerritories: fieldsTerritories, limit: limit).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: TerritoriesResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsAvailableTerritoriesGetToManyRelated(urlString: String) async throws -> TerritoriesResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsAvailableTerritoriesGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/availableTerritories
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsTerritories: (query) the fields to include for returned resources of type territories (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - returns: RequestBuilder<TerritoriesResponse> 
     */
    open class func appsAvailableTerritoriesGetToManyRelatedWithRequestBuilder(id: String, fieldsTerritories: [FieldsTerritories_appsAvailableTerritoriesGetToManyRelated]? = nil, limit: Int? = nil) -> RequestBuilder<TerritoriesResponse> {
        var localVariablePath = "/v1/apps/{id}/availableTerritories"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[territories]": fieldsTerritories?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<TerritoriesResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/availableTerritories
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<TerritoriesResponse> 
     */
    open class func appsAvailableTerritoriesGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<TerritoriesResponse> {
        let localVariableRequestBuilder: RequestBuilder<TerritoriesResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsBetaAppLocalizations
     */
    public enum FieldsBetaAppLocalizations_appsBetaAppLocalizationsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case description = "description"
        case feedbackemail = "feedbackEmail"
        case locale = "locale"
        case marketingurl = "marketingUrl"
        case privacypolicyurl = "privacyPolicyUrl"
        case tvosprivacypolicy = "tvOsPrivacyPolicy"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsBetaAppLocalizations: (query) the fields to include for returned resources of type betaAppLocalizations (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - returns: BetaAppLocalizationsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsBetaAppLocalizationsGetToManyRelated(id: String, fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations_appsBetaAppLocalizationsGetToManyRelated]? = nil, limit: Int? = nil) async throws -> BetaAppLocalizationsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsBetaAppLocalizationsGetToManyRelatedWithRequestBuilder(id: id, fieldsBetaAppLocalizations: fieldsBetaAppLocalizations, limit: limit).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: BetaAppLocalizationsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsBetaAppLocalizationsGetToManyRelated(urlString: String) async throws -> BetaAppLocalizationsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsBetaAppLocalizationsGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/betaAppLocalizations
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsBetaAppLocalizations: (query) the fields to include for returned resources of type betaAppLocalizations (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - returns: RequestBuilder<BetaAppLocalizationsResponse> 
     */
    open class func appsBetaAppLocalizationsGetToManyRelatedWithRequestBuilder(id: String, fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations_appsBetaAppLocalizationsGetToManyRelated]? = nil, limit: Int? = nil) -> RequestBuilder<BetaAppLocalizationsResponse> {
        var localVariablePath = "/v1/apps/{id}/betaAppLocalizations"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[betaAppLocalizations]": fieldsBetaAppLocalizations?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<BetaAppLocalizationsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/betaAppLocalizations
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<BetaAppLocalizationsResponse> 
     */
    open class func appsBetaAppLocalizationsGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<BetaAppLocalizationsResponse> {
        let localVariableRequestBuilder: RequestBuilder<BetaAppLocalizationsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsBetaAppReviewDetails
     */
    public enum FieldsBetaAppReviewDetails_appsBetaAppReviewDetailGetToOneRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case contactemail = "contactEmail"
        case contactfirstname = "contactFirstName"
        case contactlastname = "contactLastName"
        case contactphone = "contactPhone"
        case demoaccountname = "demoAccountName"
        case demoaccountpassword = "demoAccountPassword"
        case demoaccountrequired = "demoAccountRequired"
        case notes = "notes"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsBetaAppReviewDetails: (query) the fields to include for returned resources of type betaAppReviewDetails (optional)
     - returns: BetaAppReviewDetailResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsBetaAppReviewDetailGetToOneRelated(id: String, fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails_appsBetaAppReviewDetailGetToOneRelated]? = nil) async throws -> BetaAppReviewDetailResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsBetaAppReviewDetailGetToOneRelatedWithRequestBuilder(id: id, fieldsBetaAppReviewDetails: fieldsBetaAppReviewDetails).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: BetaAppReviewDetailResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsBetaAppReviewDetailGetToOneRelated(urlString: String) async throws -> BetaAppReviewDetailResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsBetaAppReviewDetailGetToOneRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/betaAppReviewDetail
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsBetaAppReviewDetails: (query) the fields to include for returned resources of type betaAppReviewDetails (optional)
     - returns: RequestBuilder<BetaAppReviewDetailResponse> 
     */
    open class func appsBetaAppReviewDetailGetToOneRelatedWithRequestBuilder(id: String, fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails_appsBetaAppReviewDetailGetToOneRelated]? = nil) -> RequestBuilder<BetaAppReviewDetailResponse> {
        var localVariablePath = "/v1/apps/{id}/betaAppReviewDetail"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[betaAppReviewDetails]": fieldsBetaAppReviewDetails?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<BetaAppReviewDetailResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/betaAppReviewDetail
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<BetaAppReviewDetailResponse> 
     */
    open class func appsBetaAppReviewDetailGetToOneRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<BetaAppReviewDetailResponse> {
        let localVariableRequestBuilder: RequestBuilder<BetaAppReviewDetailResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsBetaGroups
     */
    public enum FieldsBetaGroups_appsBetaGroupsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case betatesters = "betaTesters"
        case builds = "builds"
        case createddate = "createdDate"
        case feedbackenabled = "feedbackEnabled"
        case hasaccesstoallbuilds = "hasAccessToAllBuilds"
        case iosbuildsavailableforapplesiliconmac = "iosBuildsAvailableForAppleSiliconMac"
        case isinternalgroup = "isInternalGroup"
        case name = "name"
        case publiclink = "publicLink"
        case publiclinkenabled = "publicLinkEnabled"
        case publiclinkid = "publicLinkId"
        case publiclinklimit = "publicLinkLimit"
        case publiclinklimitenabled = "publicLinkLimitEnabled"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsBetaGroups: (query) the fields to include for returned resources of type betaGroups (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - returns: BetaGroupsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsBetaGroupsGetToManyRelated(id: String, fieldsBetaGroups: [FieldsBetaGroups_appsBetaGroupsGetToManyRelated]? = nil, limit: Int? = nil) async throws -> BetaGroupsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsBetaGroupsGetToManyRelatedWithRequestBuilder(id: id, fieldsBetaGroups: fieldsBetaGroups, limit: limit).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: BetaGroupsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsBetaGroupsGetToManyRelated(urlString: String) async throws -> BetaGroupsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsBetaGroupsGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/betaGroups
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsBetaGroups: (query) the fields to include for returned resources of type betaGroups (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - returns: RequestBuilder<BetaGroupsResponse> 
     */
    open class func appsBetaGroupsGetToManyRelatedWithRequestBuilder(id: String, fieldsBetaGroups: [FieldsBetaGroups_appsBetaGroupsGetToManyRelated]? = nil, limit: Int? = nil) -> RequestBuilder<BetaGroupsResponse> {
        var localVariablePath = "/v1/apps/{id}/betaGroups"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[betaGroups]": fieldsBetaGroups?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<BetaGroupsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/betaGroups
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<BetaGroupsResponse> 
     */
    open class func appsBetaGroupsGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<BetaGroupsResponse> {
        let localVariableRequestBuilder: RequestBuilder<BetaGroupsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsBetaLicenseAgreements
     */
    public enum FieldsBetaLicenseAgreements_appsBetaLicenseAgreementGetToOneRelated: String, CaseIterable, JSONEncodable {
        case agreementtext = "agreementText"
        case app = "app"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsBetaLicenseAgreements: (query) the fields to include for returned resources of type betaLicenseAgreements (optional)
     - returns: BetaLicenseAgreementResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsBetaLicenseAgreementGetToOneRelated(id: String, fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements_appsBetaLicenseAgreementGetToOneRelated]? = nil) async throws -> BetaLicenseAgreementResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsBetaLicenseAgreementGetToOneRelatedWithRequestBuilder(id: id, fieldsBetaLicenseAgreements: fieldsBetaLicenseAgreements).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: BetaLicenseAgreementResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsBetaLicenseAgreementGetToOneRelated(urlString: String) async throws -> BetaLicenseAgreementResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsBetaLicenseAgreementGetToOneRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/betaLicenseAgreement
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsBetaLicenseAgreements: (query) the fields to include for returned resources of type betaLicenseAgreements (optional)
     - returns: RequestBuilder<BetaLicenseAgreementResponse> 
     */
    open class func appsBetaLicenseAgreementGetToOneRelatedWithRequestBuilder(id: String, fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements_appsBetaLicenseAgreementGetToOneRelated]? = nil) -> RequestBuilder<BetaLicenseAgreementResponse> {
        var localVariablePath = "/v1/apps/{id}/betaLicenseAgreement"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[betaLicenseAgreements]": fieldsBetaLicenseAgreements?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<BetaLicenseAgreementResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/betaLicenseAgreement
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<BetaLicenseAgreementResponse> 
     */
    open class func appsBetaLicenseAgreementGetToOneRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<BetaLicenseAgreementResponse> {
        let localVariableRequestBuilder: RequestBuilder<BetaLicenseAgreementResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter appBetaTestersLinkagesRequest: (body) List of related linkages 
     - returns: Void
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsBetaTestersDeleteToManyRelationship(id: String, appBetaTestersLinkagesRequest: AppBetaTestersLinkagesRequest) async throws {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsBetaTestersDeleteToManyRelationshipWithRequestBuilder(id: id, appBetaTestersLinkagesRequest: appBetaTestersLinkagesRequest).execute { result in
                    switch result {
                    case .success:
                        continuation.resume(returning: ())
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: Void
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsBetaTestersDeleteToManyRelationship(urlString: String) async throws {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsBetaTestersDeleteToManyRelationshipWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case .success:
                        continuation.resume(returning: ())
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - DELETE /v1/apps/{id}/relationships/betaTesters
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter appBetaTestersLinkagesRequest: (body) List of related linkages 
     - returns: RequestBuilder<Void> 
     */
    open class func appsBetaTestersDeleteToManyRelationshipWithRequestBuilder(id: String, appBetaTestersLinkagesRequest: AppBetaTestersLinkagesRequest) -> RequestBuilder<Void> {
        var localVariablePath = "/v1/apps/{id}/relationships/betaTesters"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: appBetaTestersLinkagesRequest)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = ASCAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - DELETE /v1/apps/{id}/relationships/betaTesters
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<Void> 
     */
    open class func appsBetaTestersDeleteToManyRelationshipWithRequestBuilder(urlString: String) -> RequestBuilder<Void> {
        let localVariableRequestBuilder: RequestBuilder<Void>.Type = ASCAPI.requestBuilderFactory.getNonDecodableBuilder()
        return localVariableRequestBuilder.init(method: "DELETE", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsBuilds
     */
    public enum FieldsBuilds_appsBuildsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appencryptiondeclaration = "appEncryptionDeclaration"
        case appstoreversion = "appStoreVersion"
        case betaappreviewsubmission = "betaAppReviewSubmission"
        case betabuildlocalizations = "betaBuildLocalizations"
        case betagroups = "betaGroups"
        case buildaudiencetype = "buildAudienceType"
        case buildbetadetail = "buildBetaDetail"
        case buildbundles = "buildBundles"
        case computedminmacosversion = "computedMinMacOsVersion"
        case diagnosticsignatures = "diagnosticSignatures"
        case expirationdate = "expirationDate"
        case expired = "expired"
        case iconassettoken = "iconAssetToken"
        case icons = "icons"
        case individualtesters = "individualTesters"
        case lsminimumsystemversion = "lsMinimumSystemVersion"
        case minosversion = "minOsVersion"
        case perfpowermetrics = "perfPowerMetrics"
        case prereleaseversion = "preReleaseVersion"
        case processingstate = "processingState"
        case uploadeddate = "uploadedDate"
        case usesnonexemptencryption = "usesNonExemptEncryption"
        case version = "version"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsBuilds: (query) the fields to include for returned resources of type builds (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - returns: BuildsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsBuildsGetToManyRelated(id: String, fieldsBuilds: [FieldsBuilds_appsBuildsGetToManyRelated]? = nil, limit: Int? = nil) async throws -> BuildsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsBuildsGetToManyRelatedWithRequestBuilder(id: id, fieldsBuilds: fieldsBuilds, limit: limit).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: BuildsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsBuildsGetToManyRelated(urlString: String) async throws -> BuildsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsBuildsGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/builds
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsBuilds: (query) the fields to include for returned resources of type builds (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - returns: RequestBuilder<BuildsResponse> 
     */
    open class func appsBuildsGetToManyRelatedWithRequestBuilder(id: String, fieldsBuilds: [FieldsBuilds_appsBuildsGetToManyRelated]? = nil, limit: Int? = nil) -> RequestBuilder<BuildsResponse> {
        var localVariablePath = "/v1/apps/{id}/builds"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[builds]": fieldsBuilds?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<BuildsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/builds
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<BuildsResponse> 
     */
    open class func appsBuildsGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<BuildsResponse> {
        let localVariableRequestBuilder: RequestBuilder<BuildsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsCiProducts
     */
    public enum FieldsCiProducts_appsCiProductGetToOneRelated: String, CaseIterable, JSONEncodable {
        case additionalrepositories = "additionalRepositories"
        case app = "app"
        case buildruns = "buildRuns"
        case bundleid = "bundleId"
        case createddate = "createdDate"
        case name = "name"
        case primaryrepositories = "primaryRepositories"
        case producttype = "productType"
        case workflows = "workflows"
    }

    /**
     * enum for parameter fieldsApps
     */
    public enum FieldsApps_appsCiProductGetToOneRelated: String, CaseIterable, JSONEncodable {
        case appclips = "appClips"
        case appcustomproductpages = "appCustomProductPages"
        case appevents = "appEvents"
        case appinfos = "appInfos"
        case appstoreversions = "appStoreVersions"
        case availableinnewterritories = "availableInNewTerritories"
        case availableterritories = "availableTerritories"
        case betaapplocalizations = "betaAppLocalizations"
        case betaappreviewdetail = "betaAppReviewDetail"
        case betagroups = "betaGroups"
        case betalicenseagreement = "betaLicenseAgreement"
        case betatesters = "betaTesters"
        case builds = "builds"
        case bundleid = "bundleId"
        case ciproduct = "ciProduct"
        case contentrightsdeclaration = "contentRightsDeclaration"
        case enduserlicenseagreement = "endUserLicenseAgreement"
        case gamecenterenabledversions = "gameCenterEnabledVersions"
        case inapppurchases = "inAppPurchases"
        case isoreverwasmadeforkids = "isOrEverWasMadeForKids"
        case name = "name"
        case perfpowermetrics = "perfPowerMetrics"
        case preorder = "preOrder"
        case prereleaseversions = "preReleaseVersions"
        case pricepoints = "pricePoints"
        case prices = "prices"
        case primarylocale = "primaryLocale"
        case reviewsubmissions = "reviewSubmissions"
        case sku = "sku"
        case subscriptionstatusurl = "subscriptionStatusUrl"
        case subscriptionstatusurlforsandbox = "subscriptionStatusUrlForSandbox"
        case subscriptionstatusurlversion = "subscriptionStatusUrlVersion"
        case subscriptionstatusurlversionforsandbox = "subscriptionStatusUrlVersionForSandbox"
    }

    /**
     * enum for parameter fieldsScmRepositories
     */
    public enum FieldsScmRepositories_appsCiProductGetToOneRelated: String, CaseIterable, JSONEncodable {
        case defaultbranch = "defaultBranch"
        case gitreferences = "gitReferences"
        case httpcloneurl = "httpCloneUrl"
        case lastaccesseddate = "lastAccessedDate"
        case ownername = "ownerName"
        case pullrequests = "pullRequests"
        case repositoryname = "repositoryName"
        case scmprovider = "scmProvider"
        case sshcloneurl = "sshCloneUrl"
    }

    /**
     * enum for parameter fieldsBundleIds
     */
    public enum FieldsBundleIds_appsCiProductGetToOneRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case bundleidcapabilities = "bundleIdCapabilities"
        case identifier = "identifier"
        case name = "name"
        case platform = "platform"
        case profiles = "profiles"
        case seedid = "seedId"
    }

    /**
     * enum for parameter include
     */
    public enum Include_appsCiProductGetToOneRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case bundleid = "bundleId"
        case primaryrepositories = "primaryRepositories"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsCiProducts: (query) the fields to include for returned resources of type ciProducts (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter fieldsScmRepositories: (query) the fields to include for returned resources of type scmRepositories (optional)
     - parameter fieldsBundleIds: (query) the fields to include for returned resources of type bundleIds (optional)
     - parameter limitPrimaryRepositories: (query) maximum number of related primaryRepositories returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: CiProductResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsCiProductGetToOneRelated(id: String, fieldsCiProducts: [FieldsCiProducts_appsCiProductGetToOneRelated]? = nil, fieldsApps: [FieldsApps_appsCiProductGetToOneRelated]? = nil, fieldsScmRepositories: [FieldsScmRepositories_appsCiProductGetToOneRelated]? = nil, fieldsBundleIds: [FieldsBundleIds_appsCiProductGetToOneRelated]? = nil, limitPrimaryRepositories: Int? = nil, include: [Include_appsCiProductGetToOneRelated]? = nil) async throws -> CiProductResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsCiProductGetToOneRelatedWithRequestBuilder(id: id, fieldsCiProducts: fieldsCiProducts, fieldsApps: fieldsApps, fieldsScmRepositories: fieldsScmRepositories, fieldsBundleIds: fieldsBundleIds, limitPrimaryRepositories: limitPrimaryRepositories, include: include).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: CiProductResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsCiProductGetToOneRelated(urlString: String) async throws -> CiProductResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsCiProductGetToOneRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/ciProduct
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsCiProducts: (query) the fields to include for returned resources of type ciProducts (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter fieldsScmRepositories: (query) the fields to include for returned resources of type scmRepositories (optional)
     - parameter fieldsBundleIds: (query) the fields to include for returned resources of type bundleIds (optional)
     - parameter limitPrimaryRepositories: (query) maximum number of related primaryRepositories returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: RequestBuilder<CiProductResponse> 
     */
    open class func appsCiProductGetToOneRelatedWithRequestBuilder(id: String, fieldsCiProducts: [FieldsCiProducts_appsCiProductGetToOneRelated]? = nil, fieldsApps: [FieldsApps_appsCiProductGetToOneRelated]? = nil, fieldsScmRepositories: [FieldsScmRepositories_appsCiProductGetToOneRelated]? = nil, fieldsBundleIds: [FieldsBundleIds_appsCiProductGetToOneRelated]? = nil, limitPrimaryRepositories: Int? = nil, include: [Include_appsCiProductGetToOneRelated]? = nil) -> RequestBuilder<CiProductResponse> {
        var localVariablePath = "/v1/apps/{id}/ciProduct"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[ciProducts]": fieldsCiProducts?.encodeToJSON(),
            "fields[apps]": fieldsApps?.encodeToJSON(),
            "fields[scmRepositories]": fieldsScmRepositories?.encodeToJSON(),
            "fields[bundleIds]": fieldsBundleIds?.encodeToJSON(),
            "limit[primaryRepositories]": limitPrimaryRepositories?.encodeToJSON(),
            "include": include?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<CiProductResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/ciProduct
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<CiProductResponse> 
     */
    open class func appsCiProductGetToOneRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<CiProductResponse> {
        let localVariableRequestBuilder: RequestBuilder<CiProductResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsEndUserLicenseAgreements
     */
    public enum FieldsEndUserLicenseAgreements_appsEndUserLicenseAgreementGetToOneRelated: String, CaseIterable, JSONEncodable {
        case agreementtext = "agreementText"
        case app = "app"
        case territories = "territories"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsEndUserLicenseAgreements: (query) the fields to include for returned resources of type endUserLicenseAgreements (optional)
     - returns: EndUserLicenseAgreementResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsEndUserLicenseAgreementGetToOneRelated(id: String, fieldsEndUserLicenseAgreements: [FieldsEndUserLicenseAgreements_appsEndUserLicenseAgreementGetToOneRelated]? = nil) async throws -> EndUserLicenseAgreementResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsEndUserLicenseAgreementGetToOneRelatedWithRequestBuilder(id: id, fieldsEndUserLicenseAgreements: fieldsEndUserLicenseAgreements).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: EndUserLicenseAgreementResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsEndUserLicenseAgreementGetToOneRelated(urlString: String) async throws -> EndUserLicenseAgreementResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsEndUserLicenseAgreementGetToOneRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/endUserLicenseAgreement
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsEndUserLicenseAgreements: (query) the fields to include for returned resources of type endUserLicenseAgreements (optional)
     - returns: RequestBuilder<EndUserLicenseAgreementResponse> 
     */
    open class func appsEndUserLicenseAgreementGetToOneRelatedWithRequestBuilder(id: String, fieldsEndUserLicenseAgreements: [FieldsEndUserLicenseAgreements_appsEndUserLicenseAgreementGetToOneRelated]? = nil) -> RequestBuilder<EndUserLicenseAgreementResponse> {
        var localVariablePath = "/v1/apps/{id}/endUserLicenseAgreement"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[endUserLicenseAgreements]": fieldsEndUserLicenseAgreements?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<EndUserLicenseAgreementResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/endUserLicenseAgreement
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<EndUserLicenseAgreementResponse> 
     */
    open class func appsEndUserLicenseAgreementGetToOneRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<EndUserLicenseAgreementResponse> {
        let localVariableRequestBuilder: RequestBuilder<EndUserLicenseAgreementResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter filterPlatform
     */
    public enum FilterPlatform_appsGameCenterEnabledVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case ios = "IOS"
        case macOs = "MAC_OS"
        case tvOs = "TV_OS"
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_appsGameCenterEnabledVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case versionstring = "versionString"
        case versionstring_desc = "-versionString"
    }

    /**
     * enum for parameter fieldsGameCenterEnabledVersions
     */
    public enum FieldsGameCenterEnabledVersions_appsGameCenterEnabledVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case compatibleversions = "compatibleVersions"
        case iconasset = "iconAsset"
        case platform = "platform"
        case versionstring = "versionString"
    }

    /**
     * enum for parameter fieldsApps
     */
    public enum FieldsApps_appsGameCenterEnabledVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appclips = "appClips"
        case appcustomproductpages = "appCustomProductPages"
        case appevents = "appEvents"
        case appinfos = "appInfos"
        case appstoreversions = "appStoreVersions"
        case availableinnewterritories = "availableInNewTerritories"
        case availableterritories = "availableTerritories"
        case betaapplocalizations = "betaAppLocalizations"
        case betaappreviewdetail = "betaAppReviewDetail"
        case betagroups = "betaGroups"
        case betalicenseagreement = "betaLicenseAgreement"
        case betatesters = "betaTesters"
        case builds = "builds"
        case bundleid = "bundleId"
        case ciproduct = "ciProduct"
        case contentrightsdeclaration = "contentRightsDeclaration"
        case enduserlicenseagreement = "endUserLicenseAgreement"
        case gamecenterenabledversions = "gameCenterEnabledVersions"
        case inapppurchases = "inAppPurchases"
        case isoreverwasmadeforkids = "isOrEverWasMadeForKids"
        case name = "name"
        case perfpowermetrics = "perfPowerMetrics"
        case preorder = "preOrder"
        case prereleaseversions = "preReleaseVersions"
        case pricepoints = "pricePoints"
        case prices = "prices"
        case primarylocale = "primaryLocale"
        case reviewsubmissions = "reviewSubmissions"
        case sku = "sku"
        case subscriptionstatusurl = "subscriptionStatusUrl"
        case subscriptionstatusurlforsandbox = "subscriptionStatusUrlForSandbox"
        case subscriptionstatusurlversion = "subscriptionStatusUrlVersion"
        case subscriptionstatusurlversionforsandbox = "subscriptionStatusUrlVersionForSandbox"
    }

    /**
     * enum for parameter include
     */
    public enum Include_appsGameCenterEnabledVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case compatibleversions = "compatibleVersions"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter filterPlatform: (query) filter by attribute &#39;platform&#39; (optional)
     - parameter filterVersionString: (query) filter by attribute &#39;versionString&#39; (optional)
     - parameter filterId: (query) filter by id(s) (optional)
     - parameter sort: (query) comma-separated list of sort expressions; resources will be sorted as specified (optional)
     - parameter fieldsGameCenterEnabledVersions: (query) the fields to include for returned resources of type gameCenterEnabledVersions (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitCompatibleVersions: (query) maximum number of related compatibleVersions returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: GameCenterEnabledVersionsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsGameCenterEnabledVersionsGetToManyRelated(id: String, filterPlatform: [FilterPlatform_appsGameCenterEnabledVersionsGetToManyRelated]? = nil, filterVersionString: [String]? = nil, filterId: [String]? = nil, sort: [Sort_appsGameCenterEnabledVersionsGetToManyRelated]? = nil, fieldsGameCenterEnabledVersions: [FieldsGameCenterEnabledVersions_appsGameCenterEnabledVersionsGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsGameCenterEnabledVersionsGetToManyRelated]? = nil, limit: Int? = nil, limitCompatibleVersions: Int? = nil, include: [Include_appsGameCenterEnabledVersionsGetToManyRelated]? = nil) async throws -> GameCenterEnabledVersionsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsGameCenterEnabledVersionsGetToManyRelatedWithRequestBuilder(id: id, filterPlatform: filterPlatform, filterVersionString: filterVersionString, filterId: filterId, sort: sort, fieldsGameCenterEnabledVersions: fieldsGameCenterEnabledVersions, fieldsApps: fieldsApps, limit: limit, limitCompatibleVersions: limitCompatibleVersions, include: include).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: GameCenterEnabledVersionsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsGameCenterEnabledVersionsGetToManyRelated(urlString: String) async throws -> GameCenterEnabledVersionsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsGameCenterEnabledVersionsGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/gameCenterEnabledVersions
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter filterPlatform: (query) filter by attribute &#39;platform&#39; (optional)
     - parameter filterVersionString: (query) filter by attribute &#39;versionString&#39; (optional)
     - parameter filterId: (query) filter by id(s) (optional)
     - parameter sort: (query) comma-separated list of sort expressions; resources will be sorted as specified (optional)
     - parameter fieldsGameCenterEnabledVersions: (query) the fields to include for returned resources of type gameCenterEnabledVersions (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitCompatibleVersions: (query) maximum number of related compatibleVersions returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: RequestBuilder<GameCenterEnabledVersionsResponse> 
     */
    open class func appsGameCenterEnabledVersionsGetToManyRelatedWithRequestBuilder(id: String, filterPlatform: [FilterPlatform_appsGameCenterEnabledVersionsGetToManyRelated]? = nil, filterVersionString: [String]? = nil, filterId: [String]? = nil, sort: [Sort_appsGameCenterEnabledVersionsGetToManyRelated]? = nil, fieldsGameCenterEnabledVersions: [FieldsGameCenterEnabledVersions_appsGameCenterEnabledVersionsGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsGameCenterEnabledVersionsGetToManyRelated]? = nil, limit: Int? = nil, limitCompatibleVersions: Int? = nil, include: [Include_appsGameCenterEnabledVersionsGetToManyRelated]? = nil) -> RequestBuilder<GameCenterEnabledVersionsResponse> {
        var localVariablePath = "/v1/apps/{id}/gameCenterEnabledVersions"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "filter[platform]": filterPlatform?.encodeToJSON(),
            "filter[versionString]": filterVersionString?.encodeToJSON(),
            "filter[id]": filterId?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "fields[gameCenterEnabledVersions]": fieldsGameCenterEnabledVersions?.encodeToJSON(),
            "fields[apps]": fieldsApps?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "limit[compatibleVersions]": limitCompatibleVersions?.encodeToJSON(),
            "include": include?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<GameCenterEnabledVersionsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/gameCenterEnabledVersions
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<GameCenterEnabledVersionsResponse> 
     */
    open class func appsGameCenterEnabledVersionsGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<GameCenterEnabledVersionsResponse> {
        let localVariableRequestBuilder: RequestBuilder<GameCenterEnabledVersionsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter filterAppStoreVersionsAppStoreState
     */
    public enum FilterAppStoreVersionsAppStoreState_appsGetCollection: String, CaseIterable, JSONEncodable {
        case accepted = "ACCEPTED"
        case developerRemovedFromSale = "DEVELOPER_REMOVED_FROM_SALE"
        case developerRejected = "DEVELOPER_REJECTED"
        case inReview = "IN_REVIEW"
        case invalidBinary = "INVALID_BINARY"
        case metadataRejected = "METADATA_REJECTED"
        case pendingAppleRelease = "PENDING_APPLE_RELEASE"
        case pendingContract = "PENDING_CONTRACT"
        case pendingDeveloperRelease = "PENDING_DEVELOPER_RELEASE"
        case prepareForSubmission = "PREPARE_FOR_SUBMISSION"
        case preorderReadyForSale = "PREORDER_READY_FOR_SALE"
        case processingForAppStore = "PROCESSING_FOR_APP_STORE"
        case readyForReview = "READY_FOR_REVIEW"
        case readyForSale = "READY_FOR_SALE"
        case rejected = "REJECTED"
        case removedFromSale = "REMOVED_FROM_SALE"
        case waitingForExportCompliance = "WAITING_FOR_EXPORT_COMPLIANCE"
        case waitingForReview = "WAITING_FOR_REVIEW"
        case replacedWithNewVersion = "REPLACED_WITH_NEW_VERSION"
    }

    /**
     * enum for parameter filterAppStoreVersionsPlatform
     */
    public enum FilterAppStoreVersionsPlatform_appsGetCollection: String, CaseIterable, JSONEncodable {
        case ios = "IOS"
        case macOs = "MAC_OS"
        case tvOs = "TV_OS"
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_appsGetCollection: String, CaseIterable, JSONEncodable {
        case bundleid = "bundleId"
        case bundleid_desc = "-bundleId"
        case name = "name"
        case name_desc = "-name"
        case sku = "sku"
        case sku_desc = "-sku"
    }

    /**
     * enum for parameter fieldsApps
     */
    public enum FieldsApps_appsGetCollection: String, CaseIterable, JSONEncodable {
        case appclips = "appClips"
        case appcustomproductpages = "appCustomProductPages"
        case appevents = "appEvents"
        case appinfos = "appInfos"
        case appstoreversions = "appStoreVersions"
        case availableinnewterritories = "availableInNewTerritories"
        case availableterritories = "availableTerritories"
        case betaapplocalizations = "betaAppLocalizations"
        case betaappreviewdetail = "betaAppReviewDetail"
        case betagroups = "betaGroups"
        case betalicenseagreement = "betaLicenseAgreement"
        case betatesters = "betaTesters"
        case builds = "builds"
        case bundleid = "bundleId"
        case ciproduct = "ciProduct"
        case contentrightsdeclaration = "contentRightsDeclaration"
        case enduserlicenseagreement = "endUserLicenseAgreement"
        case gamecenterenabledversions = "gameCenterEnabledVersions"
        case inapppurchases = "inAppPurchases"
        case isoreverwasmadeforkids = "isOrEverWasMadeForKids"
        case name = "name"
        case perfpowermetrics = "perfPowerMetrics"
        case preorder = "preOrder"
        case prereleaseversions = "preReleaseVersions"
        case pricepoints = "pricePoints"
        case prices = "prices"
        case primarylocale = "primaryLocale"
        case reviewsubmissions = "reviewSubmissions"
        case sku = "sku"
        case subscriptionstatusurl = "subscriptionStatusUrl"
        case subscriptionstatusurlforsandbox = "subscriptionStatusUrlForSandbox"
        case subscriptionstatusurlversion = "subscriptionStatusUrlVersion"
        case subscriptionstatusurlversionforsandbox = "subscriptionStatusUrlVersionForSandbox"
    }

    /**
     * enum for parameter include
     */
    public enum Include_appsGetCollection: String, CaseIterable, JSONEncodable {
        case appclips = "appClips"
        case appcustomproductpages = "appCustomProductPages"
        case appevents = "appEvents"
        case appinfos = "appInfos"
        case appstoreversions = "appStoreVersions"
        case availableterritories = "availableTerritories"
        case betaapplocalizations = "betaAppLocalizations"
        case betaappreviewdetail = "betaAppReviewDetail"
        case betagroups = "betaGroups"
        case betalicenseagreement = "betaLicenseAgreement"
        case builds = "builds"
        case ciproduct = "ciProduct"
        case enduserlicenseagreement = "endUserLicenseAgreement"
        case gamecenterenabledversions = "gameCenterEnabledVersions"
        case inapppurchases = "inAppPurchases"
        case preorder = "preOrder"
        case prereleaseversions = "preReleaseVersions"
        case prices = "prices"
        case reviewsubmissions = "reviewSubmissions"
    }

    /**
     * enum for parameter fieldsBetaLicenseAgreements
     */
    public enum FieldsBetaLicenseAgreements_appsGetCollection: String, CaseIterable, JSONEncodable {
        case agreementtext = "agreementText"
        case app = "app"
    }

    /**
     * enum for parameter fieldsBetaAppReviewDetails
     */
    public enum FieldsBetaAppReviewDetails_appsGetCollection: String, CaseIterable, JSONEncodable {
        case app = "app"
        case contactemail = "contactEmail"
        case contactfirstname = "contactFirstName"
        case contactlastname = "contactLastName"
        case contactphone = "contactPhone"
        case demoaccountname = "demoAccountName"
        case demoaccountpassword = "demoAccountPassword"
        case demoaccountrequired = "demoAccountRequired"
        case notes = "notes"
    }

    /**
     * enum for parameter fieldsAppClips
     */
    public enum FieldsAppClips_appsGetCollection: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appclipadvancedexperiences = "appClipAdvancedExperiences"
        case appclipdefaultexperiences = "appClipDefaultExperiences"
        case bundleid = "bundleId"
    }

    /**
     * enum for parameter fieldsAppInfos
     */
    public enum FieldsAppInfos_appsGetCollection: String, CaseIterable, JSONEncodable {
        case ageratingdeclaration = "ageRatingDeclaration"
        case app = "app"
        case appinfolocalizations = "appInfoLocalizations"
        case appstoreagerating = "appStoreAgeRating"
        case appstorestate = "appStoreState"
        case brazilagerating = "brazilAgeRating"
        case kidsageband = "kidsAgeBand"
        case primarycategory = "primaryCategory"
        case primarysubcategoryone = "primarySubcategoryOne"
        case primarysubcategorytwo = "primarySubcategoryTwo"
        case secondarycategory = "secondaryCategory"
        case secondarysubcategoryone = "secondarySubcategoryOne"
        case secondarysubcategorytwo = "secondarySubcategoryTwo"
    }

    /**
     * enum for parameter fieldsBetaAppLocalizations
     */
    public enum FieldsBetaAppLocalizations_appsGetCollection: String, CaseIterable, JSONEncodable {
        case app = "app"
        case description = "description"
        case feedbackemail = "feedbackEmail"
        case locale = "locale"
        case marketingurl = "marketingUrl"
        case privacypolicyurl = "privacyPolicyUrl"
        case tvosprivacypolicy = "tvOsPrivacyPolicy"
    }

    /**
     * enum for parameter fieldsAppPricePoints
     */
    public enum FieldsAppPricePoints_appsGetCollection: String, CaseIterable, JSONEncodable {
        case app = "app"
        case customerprice = "customerPrice"
        case pricetier = "priceTier"
        case proceeds = "proceeds"
        case territory = "territory"
    }

    /**
     * enum for parameter fieldsInAppPurchases
     */
    public enum FieldsInAppPurchases_appsGetCollection: String, CaseIterable, JSONEncodable {
        case apps = "apps"
        case inapppurchasetype = "inAppPurchaseType"
        case productid = "productId"
        case referencename = "referenceName"
        case state = "state"
    }

    /**
     * enum for parameter fieldsPreReleaseVersions
     */
    public enum FieldsPreReleaseVersions_appsGetCollection: String, CaseIterable, JSONEncodable {
        case app = "app"
        case builds = "builds"
        case platform = "platform"
        case version = "version"
    }

    /**
     * enum for parameter fieldsCiProducts
     */
    public enum FieldsCiProducts_appsGetCollection: String, CaseIterable, JSONEncodable {
        case additionalrepositories = "additionalRepositories"
        case app = "app"
        case buildruns = "buildRuns"
        case bundleid = "bundleId"
        case createddate = "createdDate"
        case name = "name"
        case primaryrepositories = "primaryRepositories"
        case producttype = "productType"
        case workflows = "workflows"
    }

    /**
     * enum for parameter fieldsReviewSubmissions
     */
    public enum FieldsReviewSubmissions_appsGetCollection: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appstoreversionforreview = "appStoreVersionForReview"
        case canceled = "canceled"
        case items = "items"
        case platform = "platform"
        case state = "state"
        case submitted = "submitted"
        case submitteddate = "submittedDate"
    }

    /**
     * enum for parameter fieldsAppPrices
     */
    public enum FieldsAppPrices_appsGetCollection: String, CaseIterable, JSONEncodable {
        case app = "app"
        case pricetier = "priceTier"
    }

    /**
     * enum for parameter fieldsAppPreOrders
     */
    public enum FieldsAppPreOrders_appsGetCollection: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appreleasedate = "appReleaseDate"
        case preorderavailabledate = "preOrderAvailableDate"
    }

    /**
     * enum for parameter fieldsBetaGroups
     */
    public enum FieldsBetaGroups_appsGetCollection: String, CaseIterable, JSONEncodable {
        case app = "app"
        case betatesters = "betaTesters"
        case builds = "builds"
        case createddate = "createdDate"
        case feedbackenabled = "feedbackEnabled"
        case hasaccesstoallbuilds = "hasAccessToAllBuilds"
        case iosbuildsavailableforapplesiliconmac = "iosBuildsAvailableForAppleSiliconMac"
        case isinternalgroup = "isInternalGroup"
        case name = "name"
        case publiclink = "publicLink"
        case publiclinkenabled = "publicLinkEnabled"
        case publiclinkid = "publicLinkId"
        case publiclinklimit = "publicLinkLimit"
        case publiclinklimitenabled = "publicLinkLimitEnabled"
    }

    /**
     * enum for parameter fieldsGameCenterEnabledVersions
     */
    public enum FieldsGameCenterEnabledVersions_appsGetCollection: String, CaseIterable, JSONEncodable {
        case app = "app"
        case compatibleversions = "compatibleVersions"
        case iconasset = "iconAsset"
        case platform = "platform"
        case versionstring = "versionString"
    }

    /**
     * enum for parameter fieldsEndUserLicenseAgreements
     */
    public enum FieldsEndUserLicenseAgreements_appsGetCollection: String, CaseIterable, JSONEncodable {
        case agreementtext = "agreementText"
        case app = "app"
        case territories = "territories"
    }

    /**
     * enum for parameter fieldsAppStoreVersions
     */
    public enum FieldsAppStoreVersions_appsGetCollection: String, CaseIterable, JSONEncodable {
        case ageratingdeclaration = "ageRatingDeclaration"
        case app = "app"
        case appclipdefaultexperience = "appClipDefaultExperience"
        case appstorereviewdetail = "appStoreReviewDetail"
        case appstorestate = "appStoreState"
        case appstoreversionexperiments = "appStoreVersionExperiments"
        case appstoreversionlocalizations = "appStoreVersionLocalizations"
        case appstoreversionphasedrelease = "appStoreVersionPhasedRelease"
        case appstoreversionsubmission = "appStoreVersionSubmission"
        case build = "build"
        case copyright = "copyright"
        case createddate = "createdDate"
        case downloadable = "downloadable"
        case earliestreleasedate = "earliestReleaseDate"
        case idfadeclaration = "idfaDeclaration"
        case platform = "platform"
        case releasetype = "releaseType"
        case routingappcoverage = "routingAppCoverage"
        case usesidfa = "usesIdfa"
        case versionstring = "versionString"
    }

    /**
     * enum for parameter fieldsAppCustomProductPages
     */
    public enum FieldsAppCustomProductPages_appsGetCollection: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appcustomproductpageversions = "appCustomProductPageVersions"
        case appstoreversiontemplate = "appStoreVersionTemplate"
        case customproductpagetemplate = "customProductPageTemplate"
        case name = "name"
        case url = "url"
        case visible = "visible"
    }

    /**
     * enum for parameter fieldsAppEvents
     */
    public enum FieldsAppEvents_appsGetCollection: String, CaseIterable, JSONEncodable {
        case app = "app"
        case archivedterritoryschedules = "archivedTerritorySchedules"
        case badge = "badge"
        case deeplink = "deepLink"
        case eventstate = "eventState"
        case localizations = "localizations"
        case primarylocale = "primaryLocale"
        case priority = "priority"
        case purchaserequirement = "purchaseRequirement"
        case purpose = "purpose"
        case referencename = "referenceName"
        case territoryschedules = "territorySchedules"
    }

    /**
     * enum for parameter fieldsTerritories
     */
    public enum FieldsTerritories_appsGetCollection: String, CaseIterable, JSONEncodable {
        case currency = "currency"
    }

    /**
     * enum for parameter fieldsPerfPowerMetrics
     */
    public enum FieldsPerfPowerMetrics_appsGetCollection: String, CaseIterable, JSONEncodable {
        case devicetype = "deviceType"
        case metrictype = "metricType"
        case platform = "platform"
    }

    /**
     * enum for parameter fieldsBuilds
     */
    public enum FieldsBuilds_appsGetCollection: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appencryptiondeclaration = "appEncryptionDeclaration"
        case appstoreversion = "appStoreVersion"
        case betaappreviewsubmission = "betaAppReviewSubmission"
        case betabuildlocalizations = "betaBuildLocalizations"
        case betagroups = "betaGroups"
        case buildaudiencetype = "buildAudienceType"
        case buildbetadetail = "buildBetaDetail"
        case buildbundles = "buildBundles"
        case computedminmacosversion = "computedMinMacOsVersion"
        case diagnosticsignatures = "diagnosticSignatures"
        case expirationdate = "expirationDate"
        case expired = "expired"
        case iconassettoken = "iconAssetToken"
        case icons = "icons"
        case individualtesters = "individualTesters"
        case lsminimumsystemversion = "lsMinimumSystemVersion"
        case minosversion = "minOsVersion"
        case perfpowermetrics = "perfPowerMetrics"
        case prereleaseversion = "preReleaseVersion"
        case processingstate = "processingState"
        case uploadeddate = "uploadedDate"
        case usesnonexemptencryption = "usesNonExemptEncryption"
        case version = "version"
    }

    /**

     - parameter filterAppStoreVersionsAppStoreState: (query) filter by attribute &#39;appStoreVersions.appStoreState&#39; (optional)
     - parameter filterAppStoreVersionsPlatform: (query) filter by attribute &#39;appStoreVersions.platform&#39; (optional)
     - parameter filterBundleId: (query) filter by attribute &#39;bundleId&#39; (optional)
     - parameter filterName: (query) filter by attribute &#39;name&#39; (optional)
     - parameter filterSku: (query) filter by attribute &#39;sku&#39; (optional)
     - parameter filterAppStoreVersions: (query) filter by id(s) of related &#39;appStoreVersions&#39; (optional)
     - parameter filterId: (query) filter by id(s) (optional)
     - parameter existsGameCenterEnabledVersions: (query) filter by existence or non-existence of related &#39;gameCenterEnabledVersions&#39; (optional)
     - parameter sort: (query) comma-separated list of sort expressions; resources will be sorted as specified (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - parameter fieldsBetaLicenseAgreements: (query) the fields to include for returned resources of type betaLicenseAgreements (optional)
     - parameter fieldsBetaAppReviewDetails: (query) the fields to include for returned resources of type betaAppReviewDetails (optional)
     - parameter fieldsAppClips: (query) the fields to include for returned resources of type appClips (optional)
     - parameter fieldsAppInfos: (query) the fields to include for returned resources of type appInfos (optional)
     - parameter fieldsBetaAppLocalizations: (query) the fields to include for returned resources of type betaAppLocalizations (optional)
     - parameter fieldsAppPricePoints: (query) the fields to include for returned resources of type appPricePoints (optional)
     - parameter fieldsInAppPurchases: (query) the fields to include for returned resources of type inAppPurchases (optional)
     - parameter fieldsPreReleaseVersions: (query) the fields to include for returned resources of type preReleaseVersions (optional)
     - parameter fieldsCiProducts: (query) the fields to include for returned resources of type ciProducts (optional)
     - parameter fieldsReviewSubmissions: (query) the fields to include for returned resources of type reviewSubmissions (optional)
     - parameter fieldsAppPrices: (query) the fields to include for returned resources of type appPrices (optional)
     - parameter fieldsAppPreOrders: (query) the fields to include for returned resources of type appPreOrders (optional)
     - parameter fieldsBetaGroups: (query) the fields to include for returned resources of type betaGroups (optional)
     - parameter fieldsGameCenterEnabledVersions: (query) the fields to include for returned resources of type gameCenterEnabledVersions (optional)
     - parameter fieldsEndUserLicenseAgreements: (query) the fields to include for returned resources of type endUserLicenseAgreements (optional)
     - parameter fieldsAppStoreVersions: (query) the fields to include for returned resources of type appStoreVersions (optional)
     - parameter fieldsAppCustomProductPages: (query) the fields to include for returned resources of type appCustomProductPages (optional)
     - parameter fieldsAppEvents: (query) the fields to include for returned resources of type appEvents (optional)
     - parameter fieldsTerritories: (query) the fields to include for returned resources of type territories (optional)
     - parameter fieldsPerfPowerMetrics: (query) the fields to include for returned resources of type perfPowerMetrics (optional)
     - parameter fieldsBuilds: (query) the fields to include for returned resources of type builds (optional)
     - parameter limitAppClips: (query) maximum number of related appClips returned (when they are included) (optional)
     - parameter limitAppCustomProductPages: (query) maximum number of related appCustomProductPages returned (when they are included) (optional)
     - parameter limitAppEvents: (query) maximum number of related appEvents returned (when they are included) (optional)
     - parameter limitAppInfos: (query) maximum number of related appInfos returned (when they are included) (optional)
     - parameter limitAppStoreVersions: (query) maximum number of related appStoreVersions returned (when they are included) (optional)
     - parameter limitAvailableTerritories: (query) maximum number of related availableTerritories returned (when they are included) (optional)
     - parameter limitBetaAppLocalizations: (query) maximum number of related betaAppLocalizations returned (when they are included) (optional)
     - parameter limitBetaGroups: (query) maximum number of related betaGroups returned (when they are included) (optional)
     - parameter limitBuilds: (query) maximum number of related builds returned (when they are included) (optional)
     - parameter limitGameCenterEnabledVersions: (query) maximum number of related gameCenterEnabledVersions returned (when they are included) (optional)
     - parameter limitInAppPurchases: (query) maximum number of related inAppPurchases returned (when they are included) (optional)
     - parameter limitPreReleaseVersions: (query) maximum number of related preReleaseVersions returned (when they are included) (optional)
     - parameter limitPrices: (query) maximum number of related prices returned (when they are included) (optional)
     - parameter limitReviewSubmissions: (query) maximum number of related reviewSubmissions returned (when they are included) (optional)
     - returns: AppsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsGetCollection(filterAppStoreVersionsAppStoreState: [FilterAppStoreVersionsAppStoreState_appsGetCollection]? = nil, filterAppStoreVersionsPlatform: [FilterAppStoreVersionsPlatform_appsGetCollection]? = nil, filterBundleId: [String]? = nil, filterName: [String]? = nil, filterSku: [String]? = nil, filterAppStoreVersions: [String]? = nil, filterId: [String]? = nil, existsGameCenterEnabledVersions: [String]? = nil, sort: [Sort_appsGetCollection]? = nil, fieldsApps: [FieldsApps_appsGetCollection]? = nil, limit: Int? = nil, include: [Include_appsGetCollection]? = nil, fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements_appsGetCollection]? = nil, fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails_appsGetCollection]? = nil, fieldsAppClips: [FieldsAppClips_appsGetCollection]? = nil, fieldsAppInfos: [FieldsAppInfos_appsGetCollection]? = nil, fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations_appsGetCollection]? = nil, fieldsAppPricePoints: [FieldsAppPricePoints_appsGetCollection]? = nil, fieldsInAppPurchases: [FieldsInAppPurchases_appsGetCollection]? = nil, fieldsPreReleaseVersions: [FieldsPreReleaseVersions_appsGetCollection]? = nil, fieldsCiProducts: [FieldsCiProducts_appsGetCollection]? = nil, fieldsReviewSubmissions: [FieldsReviewSubmissions_appsGetCollection]? = nil, fieldsAppPrices: [FieldsAppPrices_appsGetCollection]? = nil, fieldsAppPreOrders: [FieldsAppPreOrders_appsGetCollection]? = nil, fieldsBetaGroups: [FieldsBetaGroups_appsGetCollection]? = nil, fieldsGameCenterEnabledVersions: [FieldsGameCenterEnabledVersions_appsGetCollection]? = nil, fieldsEndUserLicenseAgreements: [FieldsEndUserLicenseAgreements_appsGetCollection]? = nil, fieldsAppStoreVersions: [FieldsAppStoreVersions_appsGetCollection]? = nil, fieldsAppCustomProductPages: [FieldsAppCustomProductPages_appsGetCollection]? = nil, fieldsAppEvents: [FieldsAppEvents_appsGetCollection]? = nil, fieldsTerritories: [FieldsTerritories_appsGetCollection]? = nil, fieldsPerfPowerMetrics: [FieldsPerfPowerMetrics_appsGetCollection]? = nil, fieldsBuilds: [FieldsBuilds_appsGetCollection]? = nil, limitAppClips: Int? = nil, limitAppCustomProductPages: Int? = nil, limitAppEvents: Int? = nil, limitAppInfos: Int? = nil, limitAppStoreVersions: Int? = nil, limitAvailableTerritories: Int? = nil, limitBetaAppLocalizations: Int? = nil, limitBetaGroups: Int? = nil, limitBuilds: Int? = nil, limitGameCenterEnabledVersions: Int? = nil, limitInAppPurchases: Int? = nil, limitPreReleaseVersions: Int? = nil, limitPrices: Int? = nil, limitReviewSubmissions: Int? = nil) async throws -> AppsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsGetCollectionWithRequestBuilder(filterAppStoreVersionsAppStoreState: filterAppStoreVersionsAppStoreState, filterAppStoreVersionsPlatform: filterAppStoreVersionsPlatform, filterBundleId: filterBundleId, filterName: filterName, filterSku: filterSku, filterAppStoreVersions: filterAppStoreVersions, filterId: filterId, existsGameCenterEnabledVersions: existsGameCenterEnabledVersions, sort: sort, fieldsApps: fieldsApps, limit: limit, include: include, fieldsBetaLicenseAgreements: fieldsBetaLicenseAgreements, fieldsBetaAppReviewDetails: fieldsBetaAppReviewDetails, fieldsAppClips: fieldsAppClips, fieldsAppInfos: fieldsAppInfos, fieldsBetaAppLocalizations: fieldsBetaAppLocalizations, fieldsAppPricePoints: fieldsAppPricePoints, fieldsInAppPurchases: fieldsInAppPurchases, fieldsPreReleaseVersions: fieldsPreReleaseVersions, fieldsCiProducts: fieldsCiProducts, fieldsReviewSubmissions: fieldsReviewSubmissions, fieldsAppPrices: fieldsAppPrices, fieldsAppPreOrders: fieldsAppPreOrders, fieldsBetaGroups: fieldsBetaGroups, fieldsGameCenterEnabledVersions: fieldsGameCenterEnabledVersions, fieldsEndUserLicenseAgreements: fieldsEndUserLicenseAgreements, fieldsAppStoreVersions: fieldsAppStoreVersions, fieldsAppCustomProductPages: fieldsAppCustomProductPages, fieldsAppEvents: fieldsAppEvents, fieldsTerritories: fieldsTerritories, fieldsPerfPowerMetrics: fieldsPerfPowerMetrics, fieldsBuilds: fieldsBuilds, limitAppClips: limitAppClips, limitAppCustomProductPages: limitAppCustomProductPages, limitAppEvents: limitAppEvents, limitAppInfos: limitAppInfos, limitAppStoreVersions: limitAppStoreVersions, limitAvailableTerritories: limitAvailableTerritories, limitBetaAppLocalizations: limitBetaAppLocalizations, limitBetaGroups: limitBetaGroups, limitBuilds: limitBuilds, limitGameCenterEnabledVersions: limitGameCenterEnabledVersions, limitInAppPurchases: limitInAppPurchases, limitPreReleaseVersions: limitPreReleaseVersions, limitPrices: limitPrices, limitReviewSubmissions: limitReviewSubmissions).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: AppsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsGetCollection(urlString: String) async throws -> AppsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsGetCollectionWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter filterAppStoreVersionsAppStoreState: (query) filter by attribute &#39;appStoreVersions.appStoreState&#39; (optional)
     - parameter filterAppStoreVersionsPlatform: (query) filter by attribute &#39;appStoreVersions.platform&#39; (optional)
     - parameter filterBundleId: (query) filter by attribute &#39;bundleId&#39; (optional)
     - parameter filterName: (query) filter by attribute &#39;name&#39; (optional)
     - parameter filterSku: (query) filter by attribute &#39;sku&#39; (optional)
     - parameter filterAppStoreVersions: (query) filter by id(s) of related &#39;appStoreVersions&#39; (optional)
     - parameter filterId: (query) filter by id(s) (optional)
     - parameter existsGameCenterEnabledVersions: (query) filter by existence or non-existence of related &#39;gameCenterEnabledVersions&#39; (optional)
     - parameter sort: (query) comma-separated list of sort expressions; resources will be sorted as specified (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - parameter fieldsBetaLicenseAgreements: (query) the fields to include for returned resources of type betaLicenseAgreements (optional)
     - parameter fieldsBetaAppReviewDetails: (query) the fields to include for returned resources of type betaAppReviewDetails (optional)
     - parameter fieldsAppClips: (query) the fields to include for returned resources of type appClips (optional)
     - parameter fieldsAppInfos: (query) the fields to include for returned resources of type appInfos (optional)
     - parameter fieldsBetaAppLocalizations: (query) the fields to include for returned resources of type betaAppLocalizations (optional)
     - parameter fieldsAppPricePoints: (query) the fields to include for returned resources of type appPricePoints (optional)
     - parameter fieldsInAppPurchases: (query) the fields to include for returned resources of type inAppPurchases (optional)
     - parameter fieldsPreReleaseVersions: (query) the fields to include for returned resources of type preReleaseVersions (optional)
     - parameter fieldsCiProducts: (query) the fields to include for returned resources of type ciProducts (optional)
     - parameter fieldsReviewSubmissions: (query) the fields to include for returned resources of type reviewSubmissions (optional)
     - parameter fieldsAppPrices: (query) the fields to include for returned resources of type appPrices (optional)
     - parameter fieldsAppPreOrders: (query) the fields to include for returned resources of type appPreOrders (optional)
     - parameter fieldsBetaGroups: (query) the fields to include for returned resources of type betaGroups (optional)
     - parameter fieldsGameCenterEnabledVersions: (query) the fields to include for returned resources of type gameCenterEnabledVersions (optional)
     - parameter fieldsEndUserLicenseAgreements: (query) the fields to include for returned resources of type endUserLicenseAgreements (optional)
     - parameter fieldsAppStoreVersions: (query) the fields to include for returned resources of type appStoreVersions (optional)
     - parameter fieldsAppCustomProductPages: (query) the fields to include for returned resources of type appCustomProductPages (optional)
     - parameter fieldsAppEvents: (query) the fields to include for returned resources of type appEvents (optional)
     - parameter fieldsTerritories: (query) the fields to include for returned resources of type territories (optional)
     - parameter fieldsPerfPowerMetrics: (query) the fields to include for returned resources of type perfPowerMetrics (optional)
     - parameter fieldsBuilds: (query) the fields to include for returned resources of type builds (optional)
     - parameter limitAppClips: (query) maximum number of related appClips returned (when they are included) (optional)
     - parameter limitAppCustomProductPages: (query) maximum number of related appCustomProductPages returned (when they are included) (optional)
     - parameter limitAppEvents: (query) maximum number of related appEvents returned (when they are included) (optional)
     - parameter limitAppInfos: (query) maximum number of related appInfos returned (when they are included) (optional)
     - parameter limitAppStoreVersions: (query) maximum number of related appStoreVersions returned (when they are included) (optional)
     - parameter limitAvailableTerritories: (query) maximum number of related availableTerritories returned (when they are included) (optional)
     - parameter limitBetaAppLocalizations: (query) maximum number of related betaAppLocalizations returned (when they are included) (optional)
     - parameter limitBetaGroups: (query) maximum number of related betaGroups returned (when they are included) (optional)
     - parameter limitBuilds: (query) maximum number of related builds returned (when they are included) (optional)
     - parameter limitGameCenterEnabledVersions: (query) maximum number of related gameCenterEnabledVersions returned (when they are included) (optional)
     - parameter limitInAppPurchases: (query) maximum number of related inAppPurchases returned (when they are included) (optional)
     - parameter limitPreReleaseVersions: (query) maximum number of related preReleaseVersions returned (when they are included) (optional)
     - parameter limitPrices: (query) maximum number of related prices returned (when they are included) (optional)
     - parameter limitReviewSubmissions: (query) maximum number of related reviewSubmissions returned (when they are included) (optional)
     - returns: RequestBuilder<AppsResponse> 
     */
    open class func appsGetCollectionWithRequestBuilder(filterAppStoreVersionsAppStoreState: [FilterAppStoreVersionsAppStoreState_appsGetCollection]? = nil, filterAppStoreVersionsPlatform: [FilterAppStoreVersionsPlatform_appsGetCollection]? = nil, filterBundleId: [String]? = nil, filterName: [String]? = nil, filterSku: [String]? = nil, filterAppStoreVersions: [String]? = nil, filterId: [String]? = nil, existsGameCenterEnabledVersions: [String]? = nil, sort: [Sort_appsGetCollection]? = nil, fieldsApps: [FieldsApps_appsGetCollection]? = nil, limit: Int? = nil, include: [Include_appsGetCollection]? = nil, fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements_appsGetCollection]? = nil, fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails_appsGetCollection]? = nil, fieldsAppClips: [FieldsAppClips_appsGetCollection]? = nil, fieldsAppInfos: [FieldsAppInfos_appsGetCollection]? = nil, fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations_appsGetCollection]? = nil, fieldsAppPricePoints: [FieldsAppPricePoints_appsGetCollection]? = nil, fieldsInAppPurchases: [FieldsInAppPurchases_appsGetCollection]? = nil, fieldsPreReleaseVersions: [FieldsPreReleaseVersions_appsGetCollection]? = nil, fieldsCiProducts: [FieldsCiProducts_appsGetCollection]? = nil, fieldsReviewSubmissions: [FieldsReviewSubmissions_appsGetCollection]? = nil, fieldsAppPrices: [FieldsAppPrices_appsGetCollection]? = nil, fieldsAppPreOrders: [FieldsAppPreOrders_appsGetCollection]? = nil, fieldsBetaGroups: [FieldsBetaGroups_appsGetCollection]? = nil, fieldsGameCenterEnabledVersions: [FieldsGameCenterEnabledVersions_appsGetCollection]? = nil, fieldsEndUserLicenseAgreements: [FieldsEndUserLicenseAgreements_appsGetCollection]? = nil, fieldsAppStoreVersions: [FieldsAppStoreVersions_appsGetCollection]? = nil, fieldsAppCustomProductPages: [FieldsAppCustomProductPages_appsGetCollection]? = nil, fieldsAppEvents: [FieldsAppEvents_appsGetCollection]? = nil, fieldsTerritories: [FieldsTerritories_appsGetCollection]? = nil, fieldsPerfPowerMetrics: [FieldsPerfPowerMetrics_appsGetCollection]? = nil, fieldsBuilds: [FieldsBuilds_appsGetCollection]? = nil, limitAppClips: Int? = nil, limitAppCustomProductPages: Int? = nil, limitAppEvents: Int? = nil, limitAppInfos: Int? = nil, limitAppStoreVersions: Int? = nil, limitAvailableTerritories: Int? = nil, limitBetaAppLocalizations: Int? = nil, limitBetaGroups: Int? = nil, limitBuilds: Int? = nil, limitGameCenterEnabledVersions: Int? = nil, limitInAppPurchases: Int? = nil, limitPreReleaseVersions: Int? = nil, limitPrices: Int? = nil, limitReviewSubmissions: Int? = nil) -> RequestBuilder<AppsResponse> {
        let localVariablePath = "/v1/apps"
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "filter[appStoreVersions.appStoreState]": filterAppStoreVersionsAppStoreState?.encodeToJSON(),
            "filter[appStoreVersions.platform]": filterAppStoreVersionsPlatform?.encodeToJSON(),
            "filter[bundleId]": filterBundleId?.encodeToJSON(),
            "filter[name]": filterName?.encodeToJSON(),
            "filter[sku]": filterSku?.encodeToJSON(),
            "filter[appStoreVersions]": filterAppStoreVersions?.encodeToJSON(),
            "filter[id]": filterId?.encodeToJSON(),
            "exists[gameCenterEnabledVersions]": existsGameCenterEnabledVersions?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "fields[apps]": fieldsApps?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "include": include?.encodeToJSON(),
            "fields[betaLicenseAgreements]": fieldsBetaLicenseAgreements?.encodeToJSON(),
            "fields[betaAppReviewDetails]": fieldsBetaAppReviewDetails?.encodeToJSON(),
            "fields[appClips]": fieldsAppClips?.encodeToJSON(),
            "fields[appInfos]": fieldsAppInfos?.encodeToJSON(),
            "fields[betaAppLocalizations]": fieldsBetaAppLocalizations?.encodeToJSON(),
            "fields[appPricePoints]": fieldsAppPricePoints?.encodeToJSON(),
            "fields[inAppPurchases]": fieldsInAppPurchases?.encodeToJSON(),
            "fields[preReleaseVersions]": fieldsPreReleaseVersions?.encodeToJSON(),
            "fields[ciProducts]": fieldsCiProducts?.encodeToJSON(),
            "fields[reviewSubmissions]": fieldsReviewSubmissions?.encodeToJSON(),
            "fields[appPrices]": fieldsAppPrices?.encodeToJSON(),
            "fields[appPreOrders]": fieldsAppPreOrders?.encodeToJSON(),
            "fields[betaGroups]": fieldsBetaGroups?.encodeToJSON(),
            "fields[gameCenterEnabledVersions]": fieldsGameCenterEnabledVersions?.encodeToJSON(),
            "fields[endUserLicenseAgreements]": fieldsEndUserLicenseAgreements?.encodeToJSON(),
            "fields[appStoreVersions]": fieldsAppStoreVersions?.encodeToJSON(),
            "fields[appCustomProductPages]": fieldsAppCustomProductPages?.encodeToJSON(),
            "fields[appEvents]": fieldsAppEvents?.encodeToJSON(),
            "fields[territories]": fieldsTerritories?.encodeToJSON(),
            "fields[perfPowerMetrics]": fieldsPerfPowerMetrics?.encodeToJSON(),
            "fields[builds]": fieldsBuilds?.encodeToJSON(),
            "limit[appClips]": limitAppClips?.encodeToJSON(),
            "limit[appCustomProductPages]": limitAppCustomProductPages?.encodeToJSON(),
            "limit[appEvents]": limitAppEvents?.encodeToJSON(),
            "limit[appInfos]": limitAppInfos?.encodeToJSON(),
            "limit[appStoreVersions]": limitAppStoreVersions?.encodeToJSON(),
            "limit[availableTerritories]": limitAvailableTerritories?.encodeToJSON(),
            "limit[betaAppLocalizations]": limitBetaAppLocalizations?.encodeToJSON(),
            "limit[betaGroups]": limitBetaGroups?.encodeToJSON(),
            "limit[builds]": limitBuilds?.encodeToJSON(),
            "limit[gameCenterEnabledVersions]": limitGameCenterEnabledVersions?.encodeToJSON(),
            "limit[inAppPurchases]": limitInAppPurchases?.encodeToJSON(),
            "limit[preReleaseVersions]": limitPreReleaseVersions?.encodeToJSON(),
            "limit[prices]": limitPrices?.encodeToJSON(),
            "limit[reviewSubmissions]": limitReviewSubmissions?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AppsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<AppsResponse> 
     */
    open class func appsGetCollectionWithRequestBuilder(urlString: String) -> RequestBuilder<AppsResponse> {
        let localVariableRequestBuilder: RequestBuilder<AppsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsApps
     */
    public enum FieldsApps_appsGetInstance: String, CaseIterable, JSONEncodable {
        case appclips = "appClips"
        case appcustomproductpages = "appCustomProductPages"
        case appevents = "appEvents"
        case appinfos = "appInfos"
        case appstoreversions = "appStoreVersions"
        case availableinnewterritories = "availableInNewTerritories"
        case availableterritories = "availableTerritories"
        case betaapplocalizations = "betaAppLocalizations"
        case betaappreviewdetail = "betaAppReviewDetail"
        case betagroups = "betaGroups"
        case betalicenseagreement = "betaLicenseAgreement"
        case betatesters = "betaTesters"
        case builds = "builds"
        case bundleid = "bundleId"
        case ciproduct = "ciProduct"
        case contentrightsdeclaration = "contentRightsDeclaration"
        case enduserlicenseagreement = "endUserLicenseAgreement"
        case gamecenterenabledversions = "gameCenterEnabledVersions"
        case inapppurchases = "inAppPurchases"
        case isoreverwasmadeforkids = "isOrEverWasMadeForKids"
        case name = "name"
        case perfpowermetrics = "perfPowerMetrics"
        case preorder = "preOrder"
        case prereleaseversions = "preReleaseVersions"
        case pricepoints = "pricePoints"
        case prices = "prices"
        case primarylocale = "primaryLocale"
        case reviewsubmissions = "reviewSubmissions"
        case sku = "sku"
        case subscriptionstatusurl = "subscriptionStatusUrl"
        case subscriptionstatusurlforsandbox = "subscriptionStatusUrlForSandbox"
        case subscriptionstatusurlversion = "subscriptionStatusUrlVersion"
        case subscriptionstatusurlversionforsandbox = "subscriptionStatusUrlVersionForSandbox"
    }

    /**
     * enum for parameter include
     */
    public enum Include_appsGetInstance: String, CaseIterable, JSONEncodable {
        case appclips = "appClips"
        case appcustomproductpages = "appCustomProductPages"
        case appevents = "appEvents"
        case appinfos = "appInfos"
        case appstoreversions = "appStoreVersions"
        case availableterritories = "availableTerritories"
        case betaapplocalizations = "betaAppLocalizations"
        case betaappreviewdetail = "betaAppReviewDetail"
        case betagroups = "betaGroups"
        case betalicenseagreement = "betaLicenseAgreement"
        case builds = "builds"
        case ciproduct = "ciProduct"
        case enduserlicenseagreement = "endUserLicenseAgreement"
        case gamecenterenabledversions = "gameCenterEnabledVersions"
        case inapppurchases = "inAppPurchases"
        case preorder = "preOrder"
        case prereleaseversions = "preReleaseVersions"
        case prices = "prices"
        case reviewsubmissions = "reviewSubmissions"
    }

    /**
     * enum for parameter fieldsBetaLicenseAgreements
     */
    public enum FieldsBetaLicenseAgreements_appsGetInstance: String, CaseIterable, JSONEncodable {
        case agreementtext = "agreementText"
        case app = "app"
    }

    /**
     * enum for parameter fieldsBetaAppReviewDetails
     */
    public enum FieldsBetaAppReviewDetails_appsGetInstance: String, CaseIterable, JSONEncodable {
        case app = "app"
        case contactemail = "contactEmail"
        case contactfirstname = "contactFirstName"
        case contactlastname = "contactLastName"
        case contactphone = "contactPhone"
        case demoaccountname = "demoAccountName"
        case demoaccountpassword = "demoAccountPassword"
        case demoaccountrequired = "demoAccountRequired"
        case notes = "notes"
    }

    /**
     * enum for parameter fieldsAppClips
     */
    public enum FieldsAppClips_appsGetInstance: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appclipadvancedexperiences = "appClipAdvancedExperiences"
        case appclipdefaultexperiences = "appClipDefaultExperiences"
        case bundleid = "bundleId"
    }

    /**
     * enum for parameter fieldsAppInfos
     */
    public enum FieldsAppInfos_appsGetInstance: String, CaseIterable, JSONEncodable {
        case ageratingdeclaration = "ageRatingDeclaration"
        case app = "app"
        case appinfolocalizations = "appInfoLocalizations"
        case appstoreagerating = "appStoreAgeRating"
        case appstorestate = "appStoreState"
        case brazilagerating = "brazilAgeRating"
        case kidsageband = "kidsAgeBand"
        case primarycategory = "primaryCategory"
        case primarysubcategoryone = "primarySubcategoryOne"
        case primarysubcategorytwo = "primarySubcategoryTwo"
        case secondarycategory = "secondaryCategory"
        case secondarysubcategoryone = "secondarySubcategoryOne"
        case secondarysubcategorytwo = "secondarySubcategoryTwo"
    }

    /**
     * enum for parameter fieldsBetaAppLocalizations
     */
    public enum FieldsBetaAppLocalizations_appsGetInstance: String, CaseIterable, JSONEncodable {
        case app = "app"
        case description = "description"
        case feedbackemail = "feedbackEmail"
        case locale = "locale"
        case marketingurl = "marketingUrl"
        case privacypolicyurl = "privacyPolicyUrl"
        case tvosprivacypolicy = "tvOsPrivacyPolicy"
    }

    /**
     * enum for parameter fieldsAppPricePoints
     */
    public enum FieldsAppPricePoints_appsGetInstance: String, CaseIterable, JSONEncodable {
        case app = "app"
        case customerprice = "customerPrice"
        case pricetier = "priceTier"
        case proceeds = "proceeds"
        case territory = "territory"
    }

    /**
     * enum for parameter fieldsInAppPurchases
     */
    public enum FieldsInAppPurchases_appsGetInstance: String, CaseIterable, JSONEncodable {
        case apps = "apps"
        case inapppurchasetype = "inAppPurchaseType"
        case productid = "productId"
        case referencename = "referenceName"
        case state = "state"
    }

    /**
     * enum for parameter fieldsPreReleaseVersions
     */
    public enum FieldsPreReleaseVersions_appsGetInstance: String, CaseIterable, JSONEncodable {
        case app = "app"
        case builds = "builds"
        case platform = "platform"
        case version = "version"
    }

    /**
     * enum for parameter fieldsCiProducts
     */
    public enum FieldsCiProducts_appsGetInstance: String, CaseIterable, JSONEncodable {
        case additionalrepositories = "additionalRepositories"
        case app = "app"
        case buildruns = "buildRuns"
        case bundleid = "bundleId"
        case createddate = "createdDate"
        case name = "name"
        case primaryrepositories = "primaryRepositories"
        case producttype = "productType"
        case workflows = "workflows"
    }

    /**
     * enum for parameter fieldsReviewSubmissions
     */
    public enum FieldsReviewSubmissions_appsGetInstance: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appstoreversionforreview = "appStoreVersionForReview"
        case canceled = "canceled"
        case items = "items"
        case platform = "platform"
        case state = "state"
        case submitted = "submitted"
        case submitteddate = "submittedDate"
    }

    /**
     * enum for parameter fieldsAppPrices
     */
    public enum FieldsAppPrices_appsGetInstance: String, CaseIterable, JSONEncodable {
        case app = "app"
        case pricetier = "priceTier"
    }

    /**
     * enum for parameter fieldsAppPreOrders
     */
    public enum FieldsAppPreOrders_appsGetInstance: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appreleasedate = "appReleaseDate"
        case preorderavailabledate = "preOrderAvailableDate"
    }

    /**
     * enum for parameter fieldsBetaGroups
     */
    public enum FieldsBetaGroups_appsGetInstance: String, CaseIterable, JSONEncodable {
        case app = "app"
        case betatesters = "betaTesters"
        case builds = "builds"
        case createddate = "createdDate"
        case feedbackenabled = "feedbackEnabled"
        case hasaccesstoallbuilds = "hasAccessToAllBuilds"
        case iosbuildsavailableforapplesiliconmac = "iosBuildsAvailableForAppleSiliconMac"
        case isinternalgroup = "isInternalGroup"
        case name = "name"
        case publiclink = "publicLink"
        case publiclinkenabled = "publicLinkEnabled"
        case publiclinkid = "publicLinkId"
        case publiclinklimit = "publicLinkLimit"
        case publiclinklimitenabled = "publicLinkLimitEnabled"
    }

    /**
     * enum for parameter fieldsGameCenterEnabledVersions
     */
    public enum FieldsGameCenterEnabledVersions_appsGetInstance: String, CaseIterable, JSONEncodable {
        case app = "app"
        case compatibleversions = "compatibleVersions"
        case iconasset = "iconAsset"
        case platform = "platform"
        case versionstring = "versionString"
    }

    /**
     * enum for parameter fieldsEndUserLicenseAgreements
     */
    public enum FieldsEndUserLicenseAgreements_appsGetInstance: String, CaseIterable, JSONEncodable {
        case agreementtext = "agreementText"
        case app = "app"
        case territories = "territories"
    }

    /**
     * enum for parameter fieldsAppStoreVersions
     */
    public enum FieldsAppStoreVersions_appsGetInstance: String, CaseIterable, JSONEncodable {
        case ageratingdeclaration = "ageRatingDeclaration"
        case app = "app"
        case appclipdefaultexperience = "appClipDefaultExperience"
        case appstorereviewdetail = "appStoreReviewDetail"
        case appstorestate = "appStoreState"
        case appstoreversionexperiments = "appStoreVersionExperiments"
        case appstoreversionlocalizations = "appStoreVersionLocalizations"
        case appstoreversionphasedrelease = "appStoreVersionPhasedRelease"
        case appstoreversionsubmission = "appStoreVersionSubmission"
        case build = "build"
        case copyright = "copyright"
        case createddate = "createdDate"
        case downloadable = "downloadable"
        case earliestreleasedate = "earliestReleaseDate"
        case idfadeclaration = "idfaDeclaration"
        case platform = "platform"
        case releasetype = "releaseType"
        case routingappcoverage = "routingAppCoverage"
        case usesidfa = "usesIdfa"
        case versionstring = "versionString"
    }

    /**
     * enum for parameter fieldsAppCustomProductPages
     */
    public enum FieldsAppCustomProductPages_appsGetInstance: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appcustomproductpageversions = "appCustomProductPageVersions"
        case appstoreversiontemplate = "appStoreVersionTemplate"
        case customproductpagetemplate = "customProductPageTemplate"
        case name = "name"
        case url = "url"
        case visible = "visible"
    }

    /**
     * enum for parameter fieldsAppEvents
     */
    public enum FieldsAppEvents_appsGetInstance: String, CaseIterable, JSONEncodable {
        case app = "app"
        case archivedterritoryschedules = "archivedTerritorySchedules"
        case badge = "badge"
        case deeplink = "deepLink"
        case eventstate = "eventState"
        case localizations = "localizations"
        case primarylocale = "primaryLocale"
        case priority = "priority"
        case purchaserequirement = "purchaseRequirement"
        case purpose = "purpose"
        case referencename = "referenceName"
        case territoryschedules = "territorySchedules"
    }

    /**
     * enum for parameter fieldsTerritories
     */
    public enum FieldsTerritories_appsGetInstance: String, CaseIterable, JSONEncodable {
        case currency = "currency"
    }

    /**
     * enum for parameter fieldsPerfPowerMetrics
     */
    public enum FieldsPerfPowerMetrics_appsGetInstance: String, CaseIterable, JSONEncodable {
        case devicetype = "deviceType"
        case metrictype = "metricType"
        case platform = "platform"
    }

    /**
     * enum for parameter fieldsBuilds
     */
    public enum FieldsBuilds_appsGetInstance: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appencryptiondeclaration = "appEncryptionDeclaration"
        case appstoreversion = "appStoreVersion"
        case betaappreviewsubmission = "betaAppReviewSubmission"
        case betabuildlocalizations = "betaBuildLocalizations"
        case betagroups = "betaGroups"
        case buildaudiencetype = "buildAudienceType"
        case buildbetadetail = "buildBetaDetail"
        case buildbundles = "buildBundles"
        case computedminmacosversion = "computedMinMacOsVersion"
        case diagnosticsignatures = "diagnosticSignatures"
        case expirationdate = "expirationDate"
        case expired = "expired"
        case iconassettoken = "iconAssetToken"
        case icons = "icons"
        case individualtesters = "individualTesters"
        case lsminimumsystemversion = "lsMinimumSystemVersion"
        case minosversion = "minOsVersion"
        case perfpowermetrics = "perfPowerMetrics"
        case prereleaseversion = "preReleaseVersion"
        case processingstate = "processingState"
        case uploadeddate = "uploadedDate"
        case usesnonexemptencryption = "usesNonExemptEncryption"
        case version = "version"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - parameter fieldsBetaLicenseAgreements: (query) the fields to include for returned resources of type betaLicenseAgreements (optional)
     - parameter fieldsBetaAppReviewDetails: (query) the fields to include for returned resources of type betaAppReviewDetails (optional)
     - parameter fieldsAppClips: (query) the fields to include for returned resources of type appClips (optional)
     - parameter fieldsAppInfos: (query) the fields to include for returned resources of type appInfos (optional)
     - parameter fieldsBetaAppLocalizations: (query) the fields to include for returned resources of type betaAppLocalizations (optional)
     - parameter fieldsAppPricePoints: (query) the fields to include for returned resources of type appPricePoints (optional)
     - parameter fieldsInAppPurchases: (query) the fields to include for returned resources of type inAppPurchases (optional)
     - parameter fieldsPreReleaseVersions: (query) the fields to include for returned resources of type preReleaseVersions (optional)
     - parameter fieldsCiProducts: (query) the fields to include for returned resources of type ciProducts (optional)
     - parameter fieldsReviewSubmissions: (query) the fields to include for returned resources of type reviewSubmissions (optional)
     - parameter fieldsAppPrices: (query) the fields to include for returned resources of type appPrices (optional)
     - parameter fieldsAppPreOrders: (query) the fields to include for returned resources of type appPreOrders (optional)
     - parameter fieldsBetaGroups: (query) the fields to include for returned resources of type betaGroups (optional)
     - parameter fieldsGameCenterEnabledVersions: (query) the fields to include for returned resources of type gameCenterEnabledVersions (optional)
     - parameter fieldsEndUserLicenseAgreements: (query) the fields to include for returned resources of type endUserLicenseAgreements (optional)
     - parameter fieldsAppStoreVersions: (query) the fields to include for returned resources of type appStoreVersions (optional)
     - parameter fieldsAppCustomProductPages: (query) the fields to include for returned resources of type appCustomProductPages (optional)
     - parameter fieldsAppEvents: (query) the fields to include for returned resources of type appEvents (optional)
     - parameter fieldsTerritories: (query) the fields to include for returned resources of type territories (optional)
     - parameter fieldsPerfPowerMetrics: (query) the fields to include for returned resources of type perfPowerMetrics (optional)
     - parameter fieldsBuilds: (query) the fields to include for returned resources of type builds (optional)
     - parameter limitAppClips: (query) maximum number of related appClips returned (when they are included) (optional)
     - parameter limitAppCustomProductPages: (query) maximum number of related appCustomProductPages returned (when they are included) (optional)
     - parameter limitAppEvents: (query) maximum number of related appEvents returned (when they are included) (optional)
     - parameter limitAppInfos: (query) maximum number of related appInfos returned (when they are included) (optional)
     - parameter limitAppStoreVersions: (query) maximum number of related appStoreVersions returned (when they are included) (optional)
     - parameter limitAvailableTerritories: (query) maximum number of related availableTerritories returned (when they are included) (optional)
     - parameter limitBetaAppLocalizations: (query) maximum number of related betaAppLocalizations returned (when they are included) (optional)
     - parameter limitBetaGroups: (query) maximum number of related betaGroups returned (when they are included) (optional)
     - parameter limitBuilds: (query) maximum number of related builds returned (when they are included) (optional)
     - parameter limitGameCenterEnabledVersions: (query) maximum number of related gameCenterEnabledVersions returned (when they are included) (optional)
     - parameter limitInAppPurchases: (query) maximum number of related inAppPurchases returned (when they are included) (optional)
     - parameter limitPreReleaseVersions: (query) maximum number of related preReleaseVersions returned (when they are included) (optional)
     - parameter limitPrices: (query) maximum number of related prices returned (when they are included) (optional)
     - parameter limitReviewSubmissions: (query) maximum number of related reviewSubmissions returned (when they are included) (optional)
     - returns: AppResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsGetInstance(id: String, fieldsApps: [FieldsApps_appsGetInstance]? = nil, include: [Include_appsGetInstance]? = nil, fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements_appsGetInstance]? = nil, fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails_appsGetInstance]? = nil, fieldsAppClips: [FieldsAppClips_appsGetInstance]? = nil, fieldsAppInfos: [FieldsAppInfos_appsGetInstance]? = nil, fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations_appsGetInstance]? = nil, fieldsAppPricePoints: [FieldsAppPricePoints_appsGetInstance]? = nil, fieldsInAppPurchases: [FieldsInAppPurchases_appsGetInstance]? = nil, fieldsPreReleaseVersions: [FieldsPreReleaseVersions_appsGetInstance]? = nil, fieldsCiProducts: [FieldsCiProducts_appsGetInstance]? = nil, fieldsReviewSubmissions: [FieldsReviewSubmissions_appsGetInstance]? = nil, fieldsAppPrices: [FieldsAppPrices_appsGetInstance]? = nil, fieldsAppPreOrders: [FieldsAppPreOrders_appsGetInstance]? = nil, fieldsBetaGroups: [FieldsBetaGroups_appsGetInstance]? = nil, fieldsGameCenterEnabledVersions: [FieldsGameCenterEnabledVersions_appsGetInstance]? = nil, fieldsEndUserLicenseAgreements: [FieldsEndUserLicenseAgreements_appsGetInstance]? = nil, fieldsAppStoreVersions: [FieldsAppStoreVersions_appsGetInstance]? = nil, fieldsAppCustomProductPages: [FieldsAppCustomProductPages_appsGetInstance]? = nil, fieldsAppEvents: [FieldsAppEvents_appsGetInstance]? = nil, fieldsTerritories: [FieldsTerritories_appsGetInstance]? = nil, fieldsPerfPowerMetrics: [FieldsPerfPowerMetrics_appsGetInstance]? = nil, fieldsBuilds: [FieldsBuilds_appsGetInstance]? = nil, limitAppClips: Int? = nil, limitAppCustomProductPages: Int? = nil, limitAppEvents: Int? = nil, limitAppInfos: Int? = nil, limitAppStoreVersions: Int? = nil, limitAvailableTerritories: Int? = nil, limitBetaAppLocalizations: Int? = nil, limitBetaGroups: Int? = nil, limitBuilds: Int? = nil, limitGameCenterEnabledVersions: Int? = nil, limitInAppPurchases: Int? = nil, limitPreReleaseVersions: Int? = nil, limitPrices: Int? = nil, limitReviewSubmissions: Int? = nil) async throws -> AppResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsGetInstanceWithRequestBuilder(id: id, fieldsApps: fieldsApps, include: include, fieldsBetaLicenseAgreements: fieldsBetaLicenseAgreements, fieldsBetaAppReviewDetails: fieldsBetaAppReviewDetails, fieldsAppClips: fieldsAppClips, fieldsAppInfos: fieldsAppInfos, fieldsBetaAppLocalizations: fieldsBetaAppLocalizations, fieldsAppPricePoints: fieldsAppPricePoints, fieldsInAppPurchases: fieldsInAppPurchases, fieldsPreReleaseVersions: fieldsPreReleaseVersions, fieldsCiProducts: fieldsCiProducts, fieldsReviewSubmissions: fieldsReviewSubmissions, fieldsAppPrices: fieldsAppPrices, fieldsAppPreOrders: fieldsAppPreOrders, fieldsBetaGroups: fieldsBetaGroups, fieldsGameCenterEnabledVersions: fieldsGameCenterEnabledVersions, fieldsEndUserLicenseAgreements: fieldsEndUserLicenseAgreements, fieldsAppStoreVersions: fieldsAppStoreVersions, fieldsAppCustomProductPages: fieldsAppCustomProductPages, fieldsAppEvents: fieldsAppEvents, fieldsTerritories: fieldsTerritories, fieldsPerfPowerMetrics: fieldsPerfPowerMetrics, fieldsBuilds: fieldsBuilds, limitAppClips: limitAppClips, limitAppCustomProductPages: limitAppCustomProductPages, limitAppEvents: limitAppEvents, limitAppInfos: limitAppInfos, limitAppStoreVersions: limitAppStoreVersions, limitAvailableTerritories: limitAvailableTerritories, limitBetaAppLocalizations: limitBetaAppLocalizations, limitBetaGroups: limitBetaGroups, limitBuilds: limitBuilds, limitGameCenterEnabledVersions: limitGameCenterEnabledVersions, limitInAppPurchases: limitInAppPurchases, limitPreReleaseVersions: limitPreReleaseVersions, limitPrices: limitPrices, limitReviewSubmissions: limitReviewSubmissions).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: AppResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsGetInstance(urlString: String) async throws -> AppResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsGetInstanceWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - parameter fieldsBetaLicenseAgreements: (query) the fields to include for returned resources of type betaLicenseAgreements (optional)
     - parameter fieldsBetaAppReviewDetails: (query) the fields to include for returned resources of type betaAppReviewDetails (optional)
     - parameter fieldsAppClips: (query) the fields to include for returned resources of type appClips (optional)
     - parameter fieldsAppInfos: (query) the fields to include for returned resources of type appInfos (optional)
     - parameter fieldsBetaAppLocalizations: (query) the fields to include for returned resources of type betaAppLocalizations (optional)
     - parameter fieldsAppPricePoints: (query) the fields to include for returned resources of type appPricePoints (optional)
     - parameter fieldsInAppPurchases: (query) the fields to include for returned resources of type inAppPurchases (optional)
     - parameter fieldsPreReleaseVersions: (query) the fields to include for returned resources of type preReleaseVersions (optional)
     - parameter fieldsCiProducts: (query) the fields to include for returned resources of type ciProducts (optional)
     - parameter fieldsReviewSubmissions: (query) the fields to include for returned resources of type reviewSubmissions (optional)
     - parameter fieldsAppPrices: (query) the fields to include for returned resources of type appPrices (optional)
     - parameter fieldsAppPreOrders: (query) the fields to include for returned resources of type appPreOrders (optional)
     - parameter fieldsBetaGroups: (query) the fields to include for returned resources of type betaGroups (optional)
     - parameter fieldsGameCenterEnabledVersions: (query) the fields to include for returned resources of type gameCenterEnabledVersions (optional)
     - parameter fieldsEndUserLicenseAgreements: (query) the fields to include for returned resources of type endUserLicenseAgreements (optional)
     - parameter fieldsAppStoreVersions: (query) the fields to include for returned resources of type appStoreVersions (optional)
     - parameter fieldsAppCustomProductPages: (query) the fields to include for returned resources of type appCustomProductPages (optional)
     - parameter fieldsAppEvents: (query) the fields to include for returned resources of type appEvents (optional)
     - parameter fieldsTerritories: (query) the fields to include for returned resources of type territories (optional)
     - parameter fieldsPerfPowerMetrics: (query) the fields to include for returned resources of type perfPowerMetrics (optional)
     - parameter fieldsBuilds: (query) the fields to include for returned resources of type builds (optional)
     - parameter limitAppClips: (query) maximum number of related appClips returned (when they are included) (optional)
     - parameter limitAppCustomProductPages: (query) maximum number of related appCustomProductPages returned (when they are included) (optional)
     - parameter limitAppEvents: (query) maximum number of related appEvents returned (when they are included) (optional)
     - parameter limitAppInfos: (query) maximum number of related appInfos returned (when they are included) (optional)
     - parameter limitAppStoreVersions: (query) maximum number of related appStoreVersions returned (when they are included) (optional)
     - parameter limitAvailableTerritories: (query) maximum number of related availableTerritories returned (when they are included) (optional)
     - parameter limitBetaAppLocalizations: (query) maximum number of related betaAppLocalizations returned (when they are included) (optional)
     - parameter limitBetaGroups: (query) maximum number of related betaGroups returned (when they are included) (optional)
     - parameter limitBuilds: (query) maximum number of related builds returned (when they are included) (optional)
     - parameter limitGameCenterEnabledVersions: (query) maximum number of related gameCenterEnabledVersions returned (when they are included) (optional)
     - parameter limitInAppPurchases: (query) maximum number of related inAppPurchases returned (when they are included) (optional)
     - parameter limitPreReleaseVersions: (query) maximum number of related preReleaseVersions returned (when they are included) (optional)
     - parameter limitPrices: (query) maximum number of related prices returned (when they are included) (optional)
     - parameter limitReviewSubmissions: (query) maximum number of related reviewSubmissions returned (when they are included) (optional)
     - returns: RequestBuilder<AppResponse> 
     */
    open class func appsGetInstanceWithRequestBuilder(id: String, fieldsApps: [FieldsApps_appsGetInstance]? = nil, include: [Include_appsGetInstance]? = nil, fieldsBetaLicenseAgreements: [FieldsBetaLicenseAgreements_appsGetInstance]? = nil, fieldsBetaAppReviewDetails: [FieldsBetaAppReviewDetails_appsGetInstance]? = nil, fieldsAppClips: [FieldsAppClips_appsGetInstance]? = nil, fieldsAppInfos: [FieldsAppInfos_appsGetInstance]? = nil, fieldsBetaAppLocalizations: [FieldsBetaAppLocalizations_appsGetInstance]? = nil, fieldsAppPricePoints: [FieldsAppPricePoints_appsGetInstance]? = nil, fieldsInAppPurchases: [FieldsInAppPurchases_appsGetInstance]? = nil, fieldsPreReleaseVersions: [FieldsPreReleaseVersions_appsGetInstance]? = nil, fieldsCiProducts: [FieldsCiProducts_appsGetInstance]? = nil, fieldsReviewSubmissions: [FieldsReviewSubmissions_appsGetInstance]? = nil, fieldsAppPrices: [FieldsAppPrices_appsGetInstance]? = nil, fieldsAppPreOrders: [FieldsAppPreOrders_appsGetInstance]? = nil, fieldsBetaGroups: [FieldsBetaGroups_appsGetInstance]? = nil, fieldsGameCenterEnabledVersions: [FieldsGameCenterEnabledVersions_appsGetInstance]? = nil, fieldsEndUserLicenseAgreements: [FieldsEndUserLicenseAgreements_appsGetInstance]? = nil, fieldsAppStoreVersions: [FieldsAppStoreVersions_appsGetInstance]? = nil, fieldsAppCustomProductPages: [FieldsAppCustomProductPages_appsGetInstance]? = nil, fieldsAppEvents: [FieldsAppEvents_appsGetInstance]? = nil, fieldsTerritories: [FieldsTerritories_appsGetInstance]? = nil, fieldsPerfPowerMetrics: [FieldsPerfPowerMetrics_appsGetInstance]? = nil, fieldsBuilds: [FieldsBuilds_appsGetInstance]? = nil, limitAppClips: Int? = nil, limitAppCustomProductPages: Int? = nil, limitAppEvents: Int? = nil, limitAppInfos: Int? = nil, limitAppStoreVersions: Int? = nil, limitAvailableTerritories: Int? = nil, limitBetaAppLocalizations: Int? = nil, limitBetaGroups: Int? = nil, limitBuilds: Int? = nil, limitGameCenterEnabledVersions: Int? = nil, limitInAppPurchases: Int? = nil, limitPreReleaseVersions: Int? = nil, limitPrices: Int? = nil, limitReviewSubmissions: Int? = nil) -> RequestBuilder<AppResponse> {
        var localVariablePath = "/v1/apps/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[apps]": fieldsApps?.encodeToJSON(),
            "include": include?.encodeToJSON(),
            "fields[betaLicenseAgreements]": fieldsBetaLicenseAgreements?.encodeToJSON(),
            "fields[betaAppReviewDetails]": fieldsBetaAppReviewDetails?.encodeToJSON(),
            "fields[appClips]": fieldsAppClips?.encodeToJSON(),
            "fields[appInfos]": fieldsAppInfos?.encodeToJSON(),
            "fields[betaAppLocalizations]": fieldsBetaAppLocalizations?.encodeToJSON(),
            "fields[appPricePoints]": fieldsAppPricePoints?.encodeToJSON(),
            "fields[inAppPurchases]": fieldsInAppPurchases?.encodeToJSON(),
            "fields[preReleaseVersions]": fieldsPreReleaseVersions?.encodeToJSON(),
            "fields[ciProducts]": fieldsCiProducts?.encodeToJSON(),
            "fields[reviewSubmissions]": fieldsReviewSubmissions?.encodeToJSON(),
            "fields[appPrices]": fieldsAppPrices?.encodeToJSON(),
            "fields[appPreOrders]": fieldsAppPreOrders?.encodeToJSON(),
            "fields[betaGroups]": fieldsBetaGroups?.encodeToJSON(),
            "fields[gameCenterEnabledVersions]": fieldsGameCenterEnabledVersions?.encodeToJSON(),
            "fields[endUserLicenseAgreements]": fieldsEndUserLicenseAgreements?.encodeToJSON(),
            "fields[appStoreVersions]": fieldsAppStoreVersions?.encodeToJSON(),
            "fields[appCustomProductPages]": fieldsAppCustomProductPages?.encodeToJSON(),
            "fields[appEvents]": fieldsAppEvents?.encodeToJSON(),
            "fields[territories]": fieldsTerritories?.encodeToJSON(),
            "fields[perfPowerMetrics]": fieldsPerfPowerMetrics?.encodeToJSON(),
            "fields[builds]": fieldsBuilds?.encodeToJSON(),
            "limit[appClips]": limitAppClips?.encodeToJSON(),
            "limit[appCustomProductPages]": limitAppCustomProductPages?.encodeToJSON(),
            "limit[appEvents]": limitAppEvents?.encodeToJSON(),
            "limit[appInfos]": limitAppInfos?.encodeToJSON(),
            "limit[appStoreVersions]": limitAppStoreVersions?.encodeToJSON(),
            "limit[availableTerritories]": limitAvailableTerritories?.encodeToJSON(),
            "limit[betaAppLocalizations]": limitBetaAppLocalizations?.encodeToJSON(),
            "limit[betaGroups]": limitBetaGroups?.encodeToJSON(),
            "limit[builds]": limitBuilds?.encodeToJSON(),
            "limit[gameCenterEnabledVersions]": limitGameCenterEnabledVersions?.encodeToJSON(),
            "limit[inAppPurchases]": limitInAppPurchases?.encodeToJSON(),
            "limit[preReleaseVersions]": limitPreReleaseVersions?.encodeToJSON(),
            "limit[prices]": limitPrices?.encodeToJSON(),
            "limit[reviewSubmissions]": limitReviewSubmissions?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AppResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<AppResponse> 
     */
    open class func appsGetInstanceWithRequestBuilder(urlString: String) -> RequestBuilder<AppResponse> {
        let localVariableRequestBuilder: RequestBuilder<AppResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter filterInAppPurchaseType
     */
    public enum FilterInAppPurchaseType_appsInAppPurchasesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case automaticallyRenewableSubscription = "AUTOMATICALLY_RENEWABLE_SUBSCRIPTION"
        case nonConsumable = "NON_CONSUMABLE"
        case consumable = "CONSUMABLE"
        case nonRenewingSubscription = "NON_RENEWING_SUBSCRIPTION"
        case freeSubscription = "FREE_SUBSCRIPTION"
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_appsInAppPurchasesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case inapppurchasetype = "inAppPurchaseType"
        case inapppurchasetype_desc = "-inAppPurchaseType"
        case productid = "productId"
        case productid_desc = "-productId"
        case referencename = "referenceName"
        case referencename_desc = "-referenceName"
    }

    /**
     * enum for parameter fieldsInAppPurchases
     */
    public enum FieldsInAppPurchases_appsInAppPurchasesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case apps = "apps"
        case inapppurchasetype = "inAppPurchaseType"
        case productid = "productId"
        case referencename = "referenceName"
        case state = "state"
    }

    /**
     * enum for parameter fieldsApps
     */
    public enum FieldsApps_appsInAppPurchasesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appclips = "appClips"
        case appcustomproductpages = "appCustomProductPages"
        case appevents = "appEvents"
        case appinfos = "appInfos"
        case appstoreversions = "appStoreVersions"
        case availableinnewterritories = "availableInNewTerritories"
        case availableterritories = "availableTerritories"
        case betaapplocalizations = "betaAppLocalizations"
        case betaappreviewdetail = "betaAppReviewDetail"
        case betagroups = "betaGroups"
        case betalicenseagreement = "betaLicenseAgreement"
        case betatesters = "betaTesters"
        case builds = "builds"
        case bundleid = "bundleId"
        case ciproduct = "ciProduct"
        case contentrightsdeclaration = "contentRightsDeclaration"
        case enduserlicenseagreement = "endUserLicenseAgreement"
        case gamecenterenabledversions = "gameCenterEnabledVersions"
        case inapppurchases = "inAppPurchases"
        case isoreverwasmadeforkids = "isOrEverWasMadeForKids"
        case name = "name"
        case perfpowermetrics = "perfPowerMetrics"
        case preorder = "preOrder"
        case prereleaseversions = "preReleaseVersions"
        case pricepoints = "pricePoints"
        case prices = "prices"
        case primarylocale = "primaryLocale"
        case reviewsubmissions = "reviewSubmissions"
        case sku = "sku"
        case subscriptionstatusurl = "subscriptionStatusUrl"
        case subscriptionstatusurlforsandbox = "subscriptionStatusUrlForSandbox"
        case subscriptionstatusurlversion = "subscriptionStatusUrlVersion"
        case subscriptionstatusurlversionforsandbox = "subscriptionStatusUrlVersionForSandbox"
    }

    /**
     * enum for parameter include
     */
    public enum Include_appsInAppPurchasesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case apps = "apps"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter filterInAppPurchaseType: (query) filter by attribute &#39;inAppPurchaseType&#39; (optional)
     - parameter filterCanBeSubmitted: (query) filter by canBeSubmitted (optional)
     - parameter sort: (query) comma-separated list of sort expressions; resources will be sorted as specified (optional)
     - parameter fieldsInAppPurchases: (query) the fields to include for returned resources of type inAppPurchases (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitApps: (query) maximum number of related apps returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: InAppPurchasesResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsInAppPurchasesGetToManyRelated(id: String, filterInAppPurchaseType: [FilterInAppPurchaseType_appsInAppPurchasesGetToManyRelated]? = nil, filterCanBeSubmitted: [String]? = nil, sort: [Sort_appsInAppPurchasesGetToManyRelated]? = nil, fieldsInAppPurchases: [FieldsInAppPurchases_appsInAppPurchasesGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsInAppPurchasesGetToManyRelated]? = nil, limit: Int? = nil, limitApps: Int? = nil, include: [Include_appsInAppPurchasesGetToManyRelated]? = nil) async throws -> InAppPurchasesResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsInAppPurchasesGetToManyRelatedWithRequestBuilder(id: id, filterInAppPurchaseType: filterInAppPurchaseType, filterCanBeSubmitted: filterCanBeSubmitted, sort: sort, fieldsInAppPurchases: fieldsInAppPurchases, fieldsApps: fieldsApps, limit: limit, limitApps: limitApps, include: include).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: InAppPurchasesResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsInAppPurchasesGetToManyRelated(urlString: String) async throws -> InAppPurchasesResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsInAppPurchasesGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/inAppPurchases
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter filterInAppPurchaseType: (query) filter by attribute &#39;inAppPurchaseType&#39; (optional)
     - parameter filterCanBeSubmitted: (query) filter by canBeSubmitted (optional)
     - parameter sort: (query) comma-separated list of sort expressions; resources will be sorted as specified (optional)
     - parameter fieldsInAppPurchases: (query) the fields to include for returned resources of type inAppPurchases (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitApps: (query) maximum number of related apps returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: RequestBuilder<InAppPurchasesResponse> 
     */
    open class func appsInAppPurchasesGetToManyRelatedWithRequestBuilder(id: String, filterInAppPurchaseType: [FilterInAppPurchaseType_appsInAppPurchasesGetToManyRelated]? = nil, filterCanBeSubmitted: [String]? = nil, sort: [Sort_appsInAppPurchasesGetToManyRelated]? = nil, fieldsInAppPurchases: [FieldsInAppPurchases_appsInAppPurchasesGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsInAppPurchasesGetToManyRelated]? = nil, limit: Int? = nil, limitApps: Int? = nil, include: [Include_appsInAppPurchasesGetToManyRelated]? = nil) -> RequestBuilder<InAppPurchasesResponse> {
        var localVariablePath = "/v1/apps/{id}/inAppPurchases"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "filter[inAppPurchaseType]": filterInAppPurchaseType?.encodeToJSON(),
            "filter[canBeSubmitted]": filterCanBeSubmitted?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "fields[inAppPurchases]": fieldsInAppPurchases?.encodeToJSON(),
            "fields[apps]": fieldsApps?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "limit[apps]": limitApps?.encodeToJSON(),
            "include": include?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<InAppPurchasesResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/inAppPurchases
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<InAppPurchasesResponse> 
     */
    open class func appsInAppPurchasesGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<InAppPurchasesResponse> {
        let localVariableRequestBuilder: RequestBuilder<InAppPurchasesResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter filterMetricType
     */
    public enum FilterMetricType_appsPerfPowerMetricsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case disk = "DISK"
        case hang = "HANG"
        case battery = "BATTERY"
        case launch = "LAUNCH"
        case memory = "MEMORY"
        case animation = "ANIMATION"
        case termination = "TERMINATION"
    }

    /**
     * enum for parameter filterPlatform
     */
    public enum FilterPlatform_appsPerfPowerMetricsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case ios = "IOS"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter filterDeviceType: (query) filter by attribute &#39;deviceType&#39; (optional)
     - parameter filterMetricType: (query) filter by attribute &#39;metricType&#39; (optional)
     - parameter filterPlatform: (query) filter by attribute &#39;platform&#39; (optional)
     - returns: AnyCodable
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsPerfPowerMetricsGetToManyRelated(id: String, filterDeviceType: [String]? = nil, filterMetricType: [FilterMetricType_appsPerfPowerMetricsGetToManyRelated]? = nil, filterPlatform: [FilterPlatform_appsPerfPowerMetricsGetToManyRelated]? = nil) async throws -> AnyCodable {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsPerfPowerMetricsGetToManyRelatedWithRequestBuilder(id: id, filterDeviceType: filterDeviceType, filterMetricType: filterMetricType, filterPlatform: filterPlatform).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: AnyCodable
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsPerfPowerMetricsGetToManyRelated(urlString: String) async throws -> AnyCodable {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsPerfPowerMetricsGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/perfPowerMetrics
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter filterDeviceType: (query) filter by attribute &#39;deviceType&#39; (optional)
     - parameter filterMetricType: (query) filter by attribute &#39;metricType&#39; (optional)
     - parameter filterPlatform: (query) filter by attribute &#39;platform&#39; (optional)
     - returns: RequestBuilder<AnyCodable> 
     */
    open class func appsPerfPowerMetricsGetToManyRelatedWithRequestBuilder(id: String, filterDeviceType: [String]? = nil, filterMetricType: [FilterMetricType_appsPerfPowerMetricsGetToManyRelated]? = nil, filterPlatform: [FilterPlatform_appsPerfPowerMetricsGetToManyRelated]? = nil) -> RequestBuilder<AnyCodable> {
        var localVariablePath = "/v1/apps/{id}/perfPowerMetrics"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "filter[deviceType]": filterDeviceType?.encodeToJSON(),
            "filter[metricType]": filterMetricType?.encodeToJSON(),
            "filter[platform]": filterPlatform?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/perfPowerMetrics
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<AnyCodable> 
     */
    open class func appsPerfPowerMetricsGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<AnyCodable> {
        let localVariableRequestBuilder: RequestBuilder<AnyCodable>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsAppPreOrders
     */
    public enum FieldsAppPreOrders_appsPreOrderGetToOneRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appreleasedate = "appReleaseDate"
        case preorderavailabledate = "preOrderAvailableDate"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsAppPreOrders: (query) the fields to include for returned resources of type appPreOrders (optional)
     - returns: AppPreOrderResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsPreOrderGetToOneRelated(id: String, fieldsAppPreOrders: [FieldsAppPreOrders_appsPreOrderGetToOneRelated]? = nil) async throws -> AppPreOrderResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsPreOrderGetToOneRelatedWithRequestBuilder(id: id, fieldsAppPreOrders: fieldsAppPreOrders).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: AppPreOrderResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsPreOrderGetToOneRelated(urlString: String) async throws -> AppPreOrderResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsPreOrderGetToOneRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/preOrder
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsAppPreOrders: (query) the fields to include for returned resources of type appPreOrders (optional)
     - returns: RequestBuilder<AppPreOrderResponse> 
     */
    open class func appsPreOrderGetToOneRelatedWithRequestBuilder(id: String, fieldsAppPreOrders: [FieldsAppPreOrders_appsPreOrderGetToOneRelated]? = nil) -> RequestBuilder<AppPreOrderResponse> {
        var localVariablePath = "/v1/apps/{id}/preOrder"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[appPreOrders]": fieldsAppPreOrders?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AppPreOrderResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/preOrder
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<AppPreOrderResponse> 
     */
    open class func appsPreOrderGetToOneRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<AppPreOrderResponse> {
        let localVariableRequestBuilder: RequestBuilder<AppPreOrderResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsPreReleaseVersions
     */
    public enum FieldsPreReleaseVersions_appsPreReleaseVersionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case builds = "builds"
        case platform = "platform"
        case version = "version"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsPreReleaseVersions: (query) the fields to include for returned resources of type preReleaseVersions (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - returns: PreReleaseVersionsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsPreReleaseVersionsGetToManyRelated(id: String, fieldsPreReleaseVersions: [FieldsPreReleaseVersions_appsPreReleaseVersionsGetToManyRelated]? = nil, limit: Int? = nil) async throws -> PreReleaseVersionsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsPreReleaseVersionsGetToManyRelatedWithRequestBuilder(id: id, fieldsPreReleaseVersions: fieldsPreReleaseVersions, limit: limit).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: PreReleaseVersionsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsPreReleaseVersionsGetToManyRelated(urlString: String) async throws -> PreReleaseVersionsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsPreReleaseVersionsGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/preReleaseVersions
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsPreReleaseVersions: (query) the fields to include for returned resources of type preReleaseVersions (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - returns: RequestBuilder<PreReleaseVersionsResponse> 
     */
    open class func appsPreReleaseVersionsGetToManyRelatedWithRequestBuilder(id: String, fieldsPreReleaseVersions: [FieldsPreReleaseVersions_appsPreReleaseVersionsGetToManyRelated]? = nil, limit: Int? = nil) -> RequestBuilder<PreReleaseVersionsResponse> {
        var localVariablePath = "/v1/apps/{id}/preReleaseVersions"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[preReleaseVersions]": fieldsPreReleaseVersions?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PreReleaseVersionsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/preReleaseVersions
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<PreReleaseVersionsResponse> 
     */
    open class func appsPreReleaseVersionsGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<PreReleaseVersionsResponse> {
        let localVariableRequestBuilder: RequestBuilder<PreReleaseVersionsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsAppPriceTiers
     */
    public enum FieldsAppPriceTiers_appsPricePointsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case pricepoints = "pricePoints"
    }

    /**
     * enum for parameter fieldsAppPricePoints
     */
    public enum FieldsAppPricePoints_appsPricePointsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case customerprice = "customerPrice"
        case pricetier = "priceTier"
        case proceeds = "proceeds"
        case territory = "territory"
    }

    /**
     * enum for parameter fieldsApps
     */
    public enum FieldsApps_appsPricePointsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appclips = "appClips"
        case appcustomproductpages = "appCustomProductPages"
        case appevents = "appEvents"
        case appinfos = "appInfos"
        case appstoreversions = "appStoreVersions"
        case availableinnewterritories = "availableInNewTerritories"
        case availableterritories = "availableTerritories"
        case betaapplocalizations = "betaAppLocalizations"
        case betaappreviewdetail = "betaAppReviewDetail"
        case betagroups = "betaGroups"
        case betalicenseagreement = "betaLicenseAgreement"
        case betatesters = "betaTesters"
        case builds = "builds"
        case bundleid = "bundleId"
        case ciproduct = "ciProduct"
        case contentrightsdeclaration = "contentRightsDeclaration"
        case enduserlicenseagreement = "endUserLicenseAgreement"
        case gamecenterenabledversions = "gameCenterEnabledVersions"
        case inapppurchases = "inAppPurchases"
        case isoreverwasmadeforkids = "isOrEverWasMadeForKids"
        case name = "name"
        case perfpowermetrics = "perfPowerMetrics"
        case preorder = "preOrder"
        case prereleaseversions = "preReleaseVersions"
        case pricepoints = "pricePoints"
        case prices = "prices"
        case primarylocale = "primaryLocale"
        case reviewsubmissions = "reviewSubmissions"
        case sku = "sku"
        case subscriptionstatusurl = "subscriptionStatusUrl"
        case subscriptionstatusurlforsandbox = "subscriptionStatusUrlForSandbox"
        case subscriptionstatusurlversion = "subscriptionStatusUrlVersion"
        case subscriptionstatusurlversionforsandbox = "subscriptionStatusUrlVersionForSandbox"
    }

    /**
     * enum for parameter fieldsTerritories
     */
    public enum FieldsTerritories_appsPricePointsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case currency = "currency"
    }

    /**
     * enum for parameter include
     */
    public enum Include_appsPricePointsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case pricetier = "priceTier"
        case territory = "territory"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter filterPriceTier: (query) filter by id(s) of related &#39;priceTier&#39; (optional)
     - parameter filterTerritory: (query) filter by id(s) of related &#39;territory&#39; (optional)
     - parameter fieldsAppPriceTiers: (query) the fields to include for returned resources of type appPriceTiers (optional)
     - parameter fieldsAppPricePoints: (query) the fields to include for returned resources of type appPricePoints (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter fieldsTerritories: (query) the fields to include for returned resources of type territories (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: AppPricePointsV2Response
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsPricePointsGetToManyRelated(id: String, filterPriceTier: [String]? = nil, filterTerritory: [String]? = nil, fieldsAppPriceTiers: [FieldsAppPriceTiers_appsPricePointsGetToManyRelated]? = nil, fieldsAppPricePoints: [FieldsAppPricePoints_appsPricePointsGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsPricePointsGetToManyRelated]? = nil, fieldsTerritories: [FieldsTerritories_appsPricePointsGetToManyRelated]? = nil, limit: Int? = nil, include: [Include_appsPricePointsGetToManyRelated]? = nil) async throws -> AppPricePointsV2Response {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsPricePointsGetToManyRelatedWithRequestBuilder(id: id, filterPriceTier: filterPriceTier, filterTerritory: filterTerritory, fieldsAppPriceTiers: fieldsAppPriceTiers, fieldsAppPricePoints: fieldsAppPricePoints, fieldsApps: fieldsApps, fieldsTerritories: fieldsTerritories, limit: limit, include: include).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: AppPricePointsV2Response
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsPricePointsGetToManyRelated(urlString: String) async throws -> AppPricePointsV2Response {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsPricePointsGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/pricePoints
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter filterPriceTier: (query) filter by id(s) of related &#39;priceTier&#39; (optional)
     - parameter filterTerritory: (query) filter by id(s) of related &#39;territory&#39; (optional)
     - parameter fieldsAppPriceTiers: (query) the fields to include for returned resources of type appPriceTiers (optional)
     - parameter fieldsAppPricePoints: (query) the fields to include for returned resources of type appPricePoints (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter fieldsTerritories: (query) the fields to include for returned resources of type territories (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: RequestBuilder<AppPricePointsV2Response> 
     */
    open class func appsPricePointsGetToManyRelatedWithRequestBuilder(id: String, filterPriceTier: [String]? = nil, filterTerritory: [String]? = nil, fieldsAppPriceTiers: [FieldsAppPriceTiers_appsPricePointsGetToManyRelated]? = nil, fieldsAppPricePoints: [FieldsAppPricePoints_appsPricePointsGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsPricePointsGetToManyRelated]? = nil, fieldsTerritories: [FieldsTerritories_appsPricePointsGetToManyRelated]? = nil, limit: Int? = nil, include: [Include_appsPricePointsGetToManyRelated]? = nil) -> RequestBuilder<AppPricePointsV2Response> {
        var localVariablePath = "/v1/apps/{id}/pricePoints"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "filter[priceTier]": filterPriceTier?.encodeToJSON(),
            "filter[territory]": filterTerritory?.encodeToJSON(),
            "fields[appPriceTiers]": fieldsAppPriceTiers?.encodeToJSON(),
            "fields[appPricePoints]": fieldsAppPricePoints?.encodeToJSON(),
            "fields[apps]": fieldsApps?.encodeToJSON(),
            "fields[territories]": fieldsTerritories?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "include": include?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AppPricePointsV2Response>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/pricePoints
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<AppPricePointsV2Response> 
     */
    open class func appsPricePointsGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<AppPricePointsV2Response> {
        let localVariableRequestBuilder: RequestBuilder<AppPricePointsV2Response>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter fieldsAppPriceTiers
     */
    public enum FieldsAppPriceTiers_appsPricesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case pricepoints = "pricePoints"
    }

    /**
     * enum for parameter fieldsApps
     */
    public enum FieldsApps_appsPricesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appclips = "appClips"
        case appcustomproductpages = "appCustomProductPages"
        case appevents = "appEvents"
        case appinfos = "appInfos"
        case appstoreversions = "appStoreVersions"
        case availableinnewterritories = "availableInNewTerritories"
        case availableterritories = "availableTerritories"
        case betaapplocalizations = "betaAppLocalizations"
        case betaappreviewdetail = "betaAppReviewDetail"
        case betagroups = "betaGroups"
        case betalicenseagreement = "betaLicenseAgreement"
        case betatesters = "betaTesters"
        case builds = "builds"
        case bundleid = "bundleId"
        case ciproduct = "ciProduct"
        case contentrightsdeclaration = "contentRightsDeclaration"
        case enduserlicenseagreement = "endUserLicenseAgreement"
        case gamecenterenabledversions = "gameCenterEnabledVersions"
        case inapppurchases = "inAppPurchases"
        case isoreverwasmadeforkids = "isOrEverWasMadeForKids"
        case name = "name"
        case perfpowermetrics = "perfPowerMetrics"
        case preorder = "preOrder"
        case prereleaseversions = "preReleaseVersions"
        case pricepoints = "pricePoints"
        case prices = "prices"
        case primarylocale = "primaryLocale"
        case reviewsubmissions = "reviewSubmissions"
        case sku = "sku"
        case subscriptionstatusurl = "subscriptionStatusUrl"
        case subscriptionstatusurlforsandbox = "subscriptionStatusUrlForSandbox"
        case subscriptionstatusurlversion = "subscriptionStatusUrlVersion"
        case subscriptionstatusurlversionforsandbox = "subscriptionStatusUrlVersionForSandbox"
    }

    /**
     * enum for parameter fieldsAppPrices
     */
    public enum FieldsAppPrices_appsPricesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case pricetier = "priceTier"
    }

    /**
     * enum for parameter include
     */
    public enum Include_appsPricesGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case pricetier = "priceTier"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter fieldsAppPriceTiers: (query) the fields to include for returned resources of type appPriceTiers (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter fieldsAppPrices: (query) the fields to include for returned resources of type appPrices (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: AppPricesResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsPricesGetToManyRelated(id: String, fieldsAppPriceTiers: [FieldsAppPriceTiers_appsPricesGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsPricesGetToManyRelated]? = nil, fieldsAppPrices: [FieldsAppPrices_appsPricesGetToManyRelated]? = nil, limit: Int? = nil, include: [Include_appsPricesGetToManyRelated]? = nil) async throws -> AppPricesResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsPricesGetToManyRelatedWithRequestBuilder(id: id, fieldsAppPriceTiers: fieldsAppPriceTiers, fieldsApps: fieldsApps, fieldsAppPrices: fieldsAppPrices, limit: limit, include: include).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: AppPricesResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsPricesGetToManyRelated(urlString: String) async throws -> AppPricesResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsPricesGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/prices
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter fieldsAppPriceTiers: (query) the fields to include for returned resources of type appPriceTiers (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter fieldsAppPrices: (query) the fields to include for returned resources of type appPrices (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: RequestBuilder<AppPricesResponse> 
     */
    open class func appsPricesGetToManyRelatedWithRequestBuilder(id: String, fieldsAppPriceTiers: [FieldsAppPriceTiers_appsPricesGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsPricesGetToManyRelated]? = nil, fieldsAppPrices: [FieldsAppPrices_appsPricesGetToManyRelated]? = nil, limit: Int? = nil, include: [Include_appsPricesGetToManyRelated]? = nil) -> RequestBuilder<AppPricesResponse> {
        var localVariablePath = "/v1/apps/{id}/prices"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fields[appPriceTiers]": fieldsAppPriceTiers?.encodeToJSON(),
            "fields[apps]": fieldsApps?.encodeToJSON(),
            "fields[appPrices]": fieldsAppPrices?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "include": include?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AppPricesResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/prices
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<AppPricesResponse> 
     */
    open class func appsPricesGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<AppPricesResponse> {
        let localVariableRequestBuilder: RequestBuilder<AppPricesResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**
     * enum for parameter filterPlatform
     */
    public enum FilterPlatform_appsReviewSubmissionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case ios = "IOS"
        case macOs = "MAC_OS"
        case tvOs = "TV_OS"
    }

    /**
     * enum for parameter filterState
     */
    public enum FilterState_appsReviewSubmissionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case readyForReview = "READY_FOR_REVIEW"
        case waitingForReview = "WAITING_FOR_REVIEW"
        case inReview = "IN_REVIEW"
        case unresolvedIssues = "UNRESOLVED_ISSUES"
        case canceling = "CANCELING"
        case completing = "COMPLETING"
        case complete = "COMPLETE"
    }

    /**
     * enum for parameter fieldsReviewSubmissionItems
     */
    public enum FieldsReviewSubmissionItems_appsReviewSubmissionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appcustomproductpageversion = "appCustomProductPageVersion"
        case appevent = "appEvent"
        case appstoreversion = "appStoreVersion"
        case appstoreversionexperiment = "appStoreVersionExperiment"
        case removed = "removed"
        case resolved = "resolved"
        case reviewsubmission = "reviewSubmission"
        case state = "state"
    }

    /**
     * enum for parameter fieldsAppStoreVersions
     */
    public enum FieldsAppStoreVersions_appsReviewSubmissionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case ageratingdeclaration = "ageRatingDeclaration"
        case app = "app"
        case appclipdefaultexperience = "appClipDefaultExperience"
        case appstorereviewdetail = "appStoreReviewDetail"
        case appstorestate = "appStoreState"
        case appstoreversionexperiments = "appStoreVersionExperiments"
        case appstoreversionlocalizations = "appStoreVersionLocalizations"
        case appstoreversionphasedrelease = "appStoreVersionPhasedRelease"
        case appstoreversionsubmission = "appStoreVersionSubmission"
        case build = "build"
        case copyright = "copyright"
        case createddate = "createdDate"
        case downloadable = "downloadable"
        case earliestreleasedate = "earliestReleaseDate"
        case idfadeclaration = "idfaDeclaration"
        case platform = "platform"
        case releasetype = "releaseType"
        case routingappcoverage = "routingAppCoverage"
        case usesidfa = "usesIdfa"
        case versionstring = "versionString"
    }

    /**
     * enum for parameter fieldsApps
     */
    public enum FieldsApps_appsReviewSubmissionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case appclips = "appClips"
        case appcustomproductpages = "appCustomProductPages"
        case appevents = "appEvents"
        case appinfos = "appInfos"
        case appstoreversions = "appStoreVersions"
        case availableinnewterritories = "availableInNewTerritories"
        case availableterritories = "availableTerritories"
        case betaapplocalizations = "betaAppLocalizations"
        case betaappreviewdetail = "betaAppReviewDetail"
        case betagroups = "betaGroups"
        case betalicenseagreement = "betaLicenseAgreement"
        case betatesters = "betaTesters"
        case builds = "builds"
        case bundleid = "bundleId"
        case ciproduct = "ciProduct"
        case contentrightsdeclaration = "contentRightsDeclaration"
        case enduserlicenseagreement = "endUserLicenseAgreement"
        case gamecenterenabledversions = "gameCenterEnabledVersions"
        case inapppurchases = "inAppPurchases"
        case isoreverwasmadeforkids = "isOrEverWasMadeForKids"
        case name = "name"
        case perfpowermetrics = "perfPowerMetrics"
        case preorder = "preOrder"
        case prereleaseversions = "preReleaseVersions"
        case pricepoints = "pricePoints"
        case prices = "prices"
        case primarylocale = "primaryLocale"
        case reviewsubmissions = "reviewSubmissions"
        case sku = "sku"
        case subscriptionstatusurl = "subscriptionStatusUrl"
        case subscriptionstatusurlforsandbox = "subscriptionStatusUrlForSandbox"
        case subscriptionstatusurlversion = "subscriptionStatusUrlVersion"
        case subscriptionstatusurlversionforsandbox = "subscriptionStatusUrlVersionForSandbox"
    }

    /**
     * enum for parameter fieldsReviewSubmissions
     */
    public enum FieldsReviewSubmissions_appsReviewSubmissionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appstoreversionforreview = "appStoreVersionForReview"
        case canceled = "canceled"
        case items = "items"
        case platform = "platform"
        case state = "state"
        case submitted = "submitted"
        case submitteddate = "submittedDate"
    }

    /**
     * enum for parameter include
     */
    public enum Include_appsReviewSubmissionsGetToManyRelated: String, CaseIterable, JSONEncodable {
        case app = "app"
        case appstoreversionforreview = "appStoreVersionForReview"
        case items = "items"
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter filterPlatform: (query) filter by attribute &#39;platform&#39; (optional)
     - parameter filterState: (query) filter by attribute &#39;state&#39; (optional)
     - parameter fieldsReviewSubmissionItems: (query) the fields to include for returned resources of type reviewSubmissionItems (optional)
     - parameter fieldsAppStoreVersions: (query) the fields to include for returned resources of type appStoreVersions (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter fieldsReviewSubmissions: (query) the fields to include for returned resources of type reviewSubmissions (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitItems: (query) maximum number of related items returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: ReviewSubmissionsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsReviewSubmissionsGetToManyRelated(id: String, filterPlatform: [FilterPlatform_appsReviewSubmissionsGetToManyRelated]? = nil, filterState: [FilterState_appsReviewSubmissionsGetToManyRelated]? = nil, fieldsReviewSubmissionItems: [FieldsReviewSubmissionItems_appsReviewSubmissionsGetToManyRelated]? = nil, fieldsAppStoreVersions: [FieldsAppStoreVersions_appsReviewSubmissionsGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsReviewSubmissionsGetToManyRelated]? = nil, fieldsReviewSubmissions: [FieldsReviewSubmissions_appsReviewSubmissionsGetToManyRelated]? = nil, limit: Int? = nil, limitItems: Int? = nil, include: [Include_appsReviewSubmissionsGetToManyRelated]? = nil) async throws -> ReviewSubmissionsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsReviewSubmissionsGetToManyRelatedWithRequestBuilder(id: id, filterPlatform: filterPlatform, filterState: filterState, fieldsReviewSubmissionItems: fieldsReviewSubmissionItems, fieldsAppStoreVersions: fieldsAppStoreVersions, fieldsApps: fieldsApps, fieldsReviewSubmissions: fieldsReviewSubmissions, limit: limit, limitItems: limitItems, include: include).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: ReviewSubmissionsResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsReviewSubmissionsGetToManyRelated(urlString: String) async throws -> ReviewSubmissionsResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsReviewSubmissionsGetToManyRelatedWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - GET /v1/apps/{id}/reviewSubmissions
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter filterPlatform: (query) filter by attribute &#39;platform&#39; (optional)
     - parameter filterState: (query) filter by attribute &#39;state&#39; (optional)
     - parameter fieldsReviewSubmissionItems: (query) the fields to include for returned resources of type reviewSubmissionItems (optional)
     - parameter fieldsAppStoreVersions: (query) the fields to include for returned resources of type appStoreVersions (optional)
     - parameter fieldsApps: (query) the fields to include for returned resources of type apps (optional)
     - parameter fieldsReviewSubmissions: (query) the fields to include for returned resources of type reviewSubmissions (optional)
     - parameter limit: (query) maximum resources per page (optional)
     - parameter limitItems: (query) maximum number of related items returned (when they are included) (optional)
     - parameter include: (query) comma-separated list of relationships to include (optional)
     - returns: RequestBuilder<ReviewSubmissionsResponse> 
     */
    open class func appsReviewSubmissionsGetToManyRelatedWithRequestBuilder(id: String, filterPlatform: [FilterPlatform_appsReviewSubmissionsGetToManyRelated]? = nil, filterState: [FilterState_appsReviewSubmissionsGetToManyRelated]? = nil, fieldsReviewSubmissionItems: [FieldsReviewSubmissionItems_appsReviewSubmissionsGetToManyRelated]? = nil, fieldsAppStoreVersions: [FieldsAppStoreVersions_appsReviewSubmissionsGetToManyRelated]? = nil, fieldsApps: [FieldsApps_appsReviewSubmissionsGetToManyRelated]? = nil, fieldsReviewSubmissions: [FieldsReviewSubmissions_appsReviewSubmissionsGetToManyRelated]? = nil, limit: Int? = nil, limitItems: Int? = nil, include: [Include_appsReviewSubmissionsGetToManyRelated]? = nil) -> RequestBuilder<ReviewSubmissionsResponse> {
        var localVariablePath = "/v1/apps/{id}/reviewSubmissions"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "filter[platform]": filterPlatform?.encodeToJSON(),
            "filter[state]": filterState?.encodeToJSON(),
            "fields[reviewSubmissionItems]": fieldsReviewSubmissionItems?.encodeToJSON(),
            "fields[appStoreVersions]": fieldsAppStoreVersions?.encodeToJSON(),
            "fields[apps]": fieldsApps?.encodeToJSON(),
            "fields[reviewSubmissions]": fieldsReviewSubmissions?.encodeToJSON(),
            "limit": limit?.encodeToJSON(),
            "limit[items]": limitItems?.encodeToJSON(),
            "include": include?.encodeToJSON(),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ReviewSubmissionsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - GET /v1/apps/{id}/reviewSubmissions
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<ReviewSubmissionsResponse> 
     */
    open class func appsReviewSubmissionsGetToManyRelatedWithRequestBuilder(urlString: String) -> RequestBuilder<ReviewSubmissionsResponse> {
        let localVariableRequestBuilder: RequestBuilder<ReviewSubmissionsResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "GET", URLString: urlString, parameters: nil)
    }

    /**

     - parameter id: (path) the id of the requested resource 
     - parameter appUpdateRequest: (body) App representation 
     - returns: AppResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsUpdateInstance(id: String, appUpdateRequest: AppUpdateRequest) async throws -> AppResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsUpdateInstanceWithRequestBuilder(id: id, appUpdateRequest: appUpdateRequest).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - parameter urlString: next or first url from App Store Connect API
     - returns: AppResponse
     */
    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    open class func appsUpdateInstance(urlString: String) async throws -> AppResponse {
        var requestTask: RequestTask?
        return try await withTaskCancellationHandler {
            try Task.checkCancellation()
            return try await withCheckedThrowingContinuation { continuation in
                guard !Task.isCancelled else {
                  continuation.resume(throwing: CancellationError())
                  return
                }

                requestTask = appsUpdateInstanceWithRequestBuilder(urlString: urlString).execute { result in
                    switch result {
                    case let .success(response):
                        continuation.resume(returning: response.body)
                    case let .failure(error):
                        continuation.resume(throwing: error)
                    }
                }
            }
        } onCancel: { [requestTask] in
            requestTask?.cancel()
        }
    }

    /**
     - PATCH /v1/apps/{id}
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter id: (path) the id of the requested resource 
     - parameter appUpdateRequest: (body) App representation 
     - returns: RequestBuilder<AppResponse> 
     */
    open class func appsUpdateInstanceWithRequestBuilder(id: String, appUpdateRequest: AppUpdateRequest) -> RequestBuilder<AppResponse> {
        var localVariablePath = "/v1/apps/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = ASCAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: appUpdateRequest)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AppResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "PATCH", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters)
    }

    /**
     - PATCH /v1/apps/{id}
     - BASIC:
       - type: http
       - name: itc-bearer-token
     - parameter urlString: next or first url from App Store Connect API
     - returns: RequestBuilder<AppResponse> 
     */
    open class func appsUpdateInstanceWithRequestBuilder(urlString: String) -> RequestBuilder<AppResponse> {
        let localVariableRequestBuilder: RequestBuilder<AppResponse>.Type = ASCAPI.requestBuilderFactory.getBuilder()
        return localVariableRequestBuilder.init(method: "PATCH", URLString: urlString, parameters: nil)
    }
}
